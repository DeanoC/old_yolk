// this is direct from the maya exporter, if you try and include sas.fxh you get this instead...
const char* s_SasFxh= 
{
	"//-------------------------------------------------------------------------------------\n"
	"// Sas.fxh\n"
	"// Microsoft(R) Standard Annotations and Semantics\n"
	"// Version 1.0.0\n"
	"// Standard include file\n"
	"// Copyright (c) Microsoft Corporation. All rights reserved.\n"
	"//-------------------------------------------------------------------------------------\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"// SasHostParameterValues\n"
	"// This structure is HLSL pseudocode and will not compile. It's provided here as a\n"
	"// reference for the values which an application should expose for parameter binding.\n"
	"//-------------------------------------------------------------------------------------\n"
	"\n"
	"/*\n"
	"\n"
	"struct SasHostParameterValues\n"
	"{\n"
	"struct\n"
	"{\n"
	"float Now;  // SasBindAddress = \"Sas.Time.Now\"\n"
	"float Last; // SasBindAddress = \"Sas.Time.Last\", etc...\n"
	"int FrameNumber;\n"
	"}\n"
	"Time;\n"
	"\n"
	"textureCUBE EnvironmentMap;\n"
	"\n"
	"SasCamera Camera;\n"
	"\n"
	"SasAmbientLight AmbientLight[ZeroOrMore];\n"
	"int NumAmbientLights;\n"
	"\n"
	"SasAmbientLight DirectionalLight[ZeroOrMore];\n"
	"int NumDirectionalLights;\n"
	"\n"
	"SasAmbientLight PointLight[ZeroOrMore];\n"
	"int NumPointLights;\n"
	"\n"
	"SasAmbientLight SpotLight[ZeroOrMore];\n"
	"int NumSpotLights;\n"
	"\n"
	"struct\n"
	"{\n"
	"float4x4 WorldToShadow;\n"
	"texture2D ShadowMap;\n"
	"}\n"
	"Shadow[ZeroOrMore];\n"
	"int NumShadows;\n"
	"\n"
	"struct\n"
	"{\n"
	"float4x4 MeshToJointToWorld[OneOrMore];\n"
	"int NumJoints;\n"
	"}\n"
	"Skeleton;\n"
	"}\n"
	"Sas;\n"
	"\n"
	"*/\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"// Macros\n"
	"//-------------------------------------------------------------------------------------\n"
	"\n"
	"// The implementation’s shadow_sampler() macro must be\n"
	"// defined in the standard include as well.\n"
	"//\n"
	"// Host applications are permitted to change the\n"
	"// implementation of this macro as long as the macro\n"
	"// evaluates to a sampler_state constructor.\n"
	"//\n"
	"#define shadow_sampler(ShadowMap) \\n"
	"sampler_state \\n"
	"{ \\n"
	"Texture = (ShadowMap); \\n"
	"}\n"
	"\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"// Structures\n"
	"//-------------------------------------------------------------------------------------\n"
	"\n"
	"struct SasCamera\n"
	"{\n"
	"float4x4 WorldToView;\n"
	"float4x4 Projection;\n"
	"float2 NearFarClipping;\n"
	"float3 Position;\n"
	"};\n"
	"\n"
	"struct SasAmbientLight\n"
	"{\n"
	"float3 Color;         // default: {0, 0, 0}\n"
	"};\n"
	"\n"
	"struct SasDirectionalLight\n"
	"{\n"
	"float3 Color;         // default: {0, 0, 0}\n"
	"float3 Direction;     // default: {0, 0, 0}\n"
	"};\n"
	"\n"
	"struct SasPointLight\n"
	"{\n"
	"float3 Color;         // default: {0, 0, 0}\n"
	"float3 Position;      // default: {0, 0, 0}\n"
	"float  Range;         // default: 0\n"
	"};\n"
	"\n"
	"struct SasSpotLight\n"
	"{\n"
	"float3 Color;         // default: {0, 0, 0}\n"
	"float3 Position;      // default: {0, 0, 0}\n"
	"float  Direction;     // default: {0, 0, 0}\n"
	"float  Range;         // default: 0\n"
	"float  Theta;         // default: 0\n"
	"float  Phi;           // default: 0\n"
	"};\n"
	"\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"// Functions\n"
	"//-------------------------------------------------------------------------------------\n"
	"\n"
	"// The following provide generalized inverse of a matrix.\n"
	"// They cannot assume anything about the matrix.\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"float3x3 inverse(float3x3 m)\n"
	"{\n"
	"float3x3 adj;\n"
	"\n"
	"// Calculate the adjoint matrix\n"
	"adj._11 = m._22*m._33 - m._23*m._32;\n"
	"adj._12 = m._13*m._32 - m._12*m._33;\n"
	"adj._13 = m._12*m._23 - m._13*m._22;\n"
	"\n"
	"adj._21 = m._23*m._31 - m._21*m._33;\n"
	"adj._22 = m._11*m._33 - m._13*m._31;\n"
	"adj._23 = m._13*m._21 - m._11*m._23;\n"
	"\n"
	"adj._31 = m._21*m._32 - m._22*m._31;\n"
	"adj._32 = m._12*m._31 - m._11*m._32;\n"
	"adj._33 = m._11*m._22 - m._12*m._21;\n"
	"\n"
	"// Calculate the determinant\n"
	"float det = determinant(m);\n"
	"\n"
	"float3x3 result = 0;\n"
	"if( 0.0f != det )\n"
	"result = 1.0f/det * adj;\n"
	"\n"
	"return result;\n"
	"}\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"float4x4 inverse(float4x4 m)\n"
	"{\n"
	"float4x4 adj;\n"
	"\n"
	"// Calculate the adjoint matrix\n"
	"adj._11 = m._22*m._33*m._44 + m._23*m._34*m._42 + m._24*m._32*m._43 - m._22*m._34*m._43 - m._23*m._32*m._44 - m._24*m._33*m._42;\n"
	"adj._12 = m._12*m._34*m._43 + m._13*m._32*m._44 + m._14*m._33*m._42 - m._12*m._33*m._44 - m._13*m._34*m._42 - m._14*m._32*m._43;\n"
	"adj._13 = m._12*m._23*m._44 + m._13*m._24*m._42 + m._14*m._22*m._43 - m._12*m._24*m._43 - m._13*m._22*m._44 - m._14*m._23*m._42;\n"
	"adj._14 = m._12*m._24*m._33 + m._13*m._22*m._34 + m._14*m._23*m._32 - m._12*m._23*m._34 - m._13*m._24*m._32 - m._14*m._22*m._33;\n"
	"\n"
	"adj._21 = m._21*m._34*m._43 + m._23*m._31*m._44 + m._24*m._33*m._41 - m._21*m._33*m._44 - m._23*m._34*m._41 - m._24*m._31*m._43;\n"
	"adj._22 = m._11*m._33*m._44 + m._13*m._34*m._41 + m._14*m._31*m._43 - m._11*m._34*m._43 - m._13*m._31*m._44 - m._14*m._33*m._41;\n"
	"adj._23 = m._11*m._24*m._43 + m._13*m._21*m._44 + m._14*m._23*m._41 - m._11*m._23*m._44 - m._13*m._24*m._41 - m._14*m._21*m._43;\n"
	"adj._24 = m._11*m._23*m._34 + m._13*m._24*m._31 + m._14*m._21*m._33 - m._11*m._24*m._33 - m._13*m._21*m._34 - m._14*m._23*m._31;\n"
	"\n"
	"adj._31 = m._21*m._32*m._44 + m._22*m._34*m._41 + m._24*m._31*m._42 - m._21*m._34*m._42 - m._22*m._31*m._44 - m._24*m._32*m._41;\n"
	"adj._32 = m._11*m._34*m._42 + m._12*m._31*m._44 + m._14*m._32*m._41 - m._11*m._32*m._44 - m._12*m._34*m._41 - m._14*m._31*m._42;\n"
	"adj._33 = m._11*m._22*m._44 + m._12*m._24*m._41 + m._14*m._21*m._42 - m._11*m._24*m._42 - m._12*m._21*m._44 - m._14*m._22*m._41;\n"
	"adj._34 = m._11*m._24*m._32 + m._12*m._21*m._34 + m._14*m._22*m._31 - m._11*m._22*m._34 - m._12*m._24*m._31 - m._14*m._21*m._32;\n"
	"\n"
	"adj._41 = m._21*m._33*m._42 + m._22*m._31*m._43 + m._23*m._32*m._41 - m._21*m._32*m._43 - m._22*m._33*m._41 - m._23*m._31*m._42;\n"
	"adj._42 = m._11*m._32*m._43 + m._12*m._33*m._41 + m._13*m._31*m._42 - m._11*m._33*m._42 - m._12*m._31*m._43 - m._13*m._32*m._41;\n"
	"adj._43 = m._11*m._23*m._42 + m._12*m._21*m._43 + m._13*m._22*m._41 - m._11*m._22*m._43 - m._12*m._23*m._41 - m._13*m._21*m._42;\n"
	"adj._44 = m._11*m._22*m._33 + m._12*m._23*m._31 + m._13*m._21*m._32 - m._11*m._23*m._32 - m._12*m._21*m._33 - m._13*m._22*m._31;\n"
	"\n"
	"// Calculate the determinant\n"
	"float det = determinant(m);\n"
	"\n"
	"float4x4 result = 0;\n"
	"if( 0.0f != det )\n"
	"result = 1.0f/det * adj;\n"
	"\n"
	"return result;\n"
	"}\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"float4x3 inverse(float4x3 m)\n"
	"{\n"
	"// Separate the rotation and translation components\n"
	"float3x3 R = (float3x3)m;\n"
	"float1x3 t = { m._41, m._42, m._43 };\n"
	"\n"
	"// Find the inverse matrix\n"
	"// A0 R0\n"
	"// v1 t1 = I\n"
	"\n"
	"float3x3 A = inverse( R );\n"
	"float1x3 v = -mul( A, t );\n"
	"\n"
	"return float4x3( A._11, A._12, A._13,\n"
	"A._21, A._22, A._23,\n"
	"A._31, A._32, A._33,\n"
	"v._11, v._12, v._13 );\n"
	"}\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"float3x4 inverse(float3x4 m)\n"
	"{\n"
	"// Separate the rotation and translation components\n"
	"float3x3 R = (float3x3)m;\n"
	"float3x1 t = { m._14, m._24, m._34 };\n"
	"\n"
	"// Find the inverse matrix\n"
	"// Av Rt\n"
	"// 01 01 = I\n"
	"\n"
	"float3x3 A = inverse( R );\n"
	"float3x1 v = -mul( A, t );\n"
	"\n"
	"return float3x4( A._11, A._12, A._13, v._11,\n"
	"A._21, A._22, A._23, v._21,\n"
	"A._31, A._32, A._33, v._31 );\n"
	"}\n"
	"\n"
	"\n"
	"// The following provide faster versions of inverse that assume the matrix is orthogonal.\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"float3x3 inverse_orthogonal(float3x3 m)\n"
	"{\n"
	"float length0 = length(m[0]);\n"
	"float length1 = length(m[1]);\n"
	"float length2 = length(m[2]);\n"
	"\n"
	"m[0] /= length0 * length0;\n"
	"m[1] /= length1 * length1;\n"
	"m[2] /= length2 * length2;\n"
	"\n"
	"return transpose(m);\n"
	"}\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"float4x4 inverse_orthogonal(float4x4 m)\n"
	"{\n"
	"float length0 = length(m[0]);\n"
	"float length1 = length(m[1]);\n"
	"float length2 = length(m[2]);\n"
	"float length3 = length(m[3]);\n"
	"\n"
	"m[0] /= length0 * length0;\n"
	"m[1] /= length1 * length1;\n"
	"m[2] /= length2 * length2;\n"
	"m[3] /= length3 * length3;\n"
	"\n"
	"return transpose(m);\n"
	"}\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"float4x3 inverse_orthogonal(float4x3 m)\n"
	"{\n"
	"// Separate the rotation and translation components\n"
	"float3x3 R = (float3x3)m;\n"
	"float1x3 t = { m._41, m._42, m._43 };\n"
	"\n"
	"// Find the inverse matrix\n"
	"// A0 R0\n"
	"// v1 t1 = I\n"
	"\n"
	"float3x3 A = inverse_orthogonal( R );\n"
	"float1x3 v = -mul( A, t );\n"
	"\n"
	"return float4x3( A._11, A._12, A._13,\n"
	"A._21, A._22, A._23,\n"
	"A._31, A._32, A._33,\n"
	"v._11, v._12, v._13 );\n"
	"}\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"float3x4 inverse_orthogonal(float3x4 m)\n"
	"{\n"
	"// Separate the rotation and translation components\n"
	"float3x3 R = (float3x3)m;\n"
	"float3x1 t = { m._14, m._24, m._34 };\n"
	"\n"
	"// Find the inverse matrix\n"
	"// Av Rt\n"
	"// 01 01 = I\n"
	"\n"
	"float3x3 A = inverse_orthogonal( R );\n"
	"float3x1 v = -mul( A, t );\n"
	"\n"
	"return float3x4( A._11, A._12, A._13, v._11,\n"
	"A._21, A._22, A._23, v._21,\n"
	"A._31, A._32, A._33, v._31 );\n"
	"}\n"
	"\n"
	"\n"
	"// The following provide faster versions of inverse that assume the matrix is orthonormal.\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"float3x3 inverse_orthonormal(float3x3 m)\n"
	"{\n"
	"return transpose(m);\n"
	"}\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"float4x4 inverse_orthonormal(float4x4 m)\n"
	"{\n"
	"return transpose(m);\n"
	"}\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"float4x3 inverse_orthonormal(float4x3 m)\n"
	"{\n"
	"// Separate the rotation and translation components\n"
	"float3x3 R = (float3x3)m;\n"
	"float1x3 t = { m._41, m._42, m._43 };\n"
	"\n"
	"// Find the inverse matrix\n"
	"// A0 R0\n"
	"// v1 t1 = I\n"
	"\n"
	"float3x3 A = inverse_orthonormal( R );\n"
	"float1x3 v = -mul( A, t );\n"
	"\n"
	"return float4x3( A._11, A._12, A._13,\n"
	"A._21, A._22, A._23,\n"
	"A._31, A._32, A._33,\n"
	"v._11, v._12, v._13 );\n"
	"}\n"
	"\n"
	"//-------------------------------------------------------------------------------------\n"
	"float3x4 inverse_orthonormal(float3x4 m)\n"
	"{\n"
	"// Separate the rotation and translation components\n"
	"float3x3 R = (float3x3)m;\n"
	"float3x1 t = { m._14, m._24, m._34 };\n"
	"\n"
	"// Find the inverse matrix\n"
	"// Av Rt\n"
	"// 01 01 = I\n"
	"\n"
	"float3x3 A = inverse_orthonormal( R );\n"
	"float3x1 v = -mul( A, t );\n"
	"\n"
	"return float3x4( A._11, A._12, A._13, v._11,\n"
	"A._21, A._22, A._23, v._21,\n"
	"A._31, A._32, A._33, v._31 );\n"
	"}\n"
	"\n"
	"\n"
	"// The implementation’s shadow() sampling function must\n"
	"// be defined in the standard include as well.\n"
	"//-------------------------------------------------------------------------------------\n"
	"float shadow( sampler ShadowSampler, float4x4 WorldToShadow, float3 WorldPoint)\n"
	"{\n"
	"return 0.0;\n"
	"}\n"
};