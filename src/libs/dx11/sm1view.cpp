///-------------------------------------------------------------------------------------------------
/// \file	graphics\sm1view.cpp
///
/// \brief	Implements the sm 1view class.
///
/// \details	
///		sm_1view description goes here
///
/// \remark	Copyright (c) 2011 Dean Calver. All rights reserved.
/// \remark	mailto://deano@rattie.demon.co.uk
///
/// \todo	Fill in detailed file description.
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "dx11.h"
#include "rendercontext.h"
#include "vdeclmanager.h"
#include "sm1view.h"

namespace Dx11 {

int SM1view::nameCounter = 0;

SM1view::SM1view() {

	width = Gfx::Get()->getScreenWidth() / 1;
	height = Gfx::Get()->getScreenHeight() / 1;
	char charbuf[1024];

	// --- fragment buffer --- stores all the intersection hits generated by the renderer
	// each fragment is currently 16 bytes!
	const int maxFragments = 10 * 1024 * 1024; // 160 MiB
	sprintf( charbuf, "%s%i", "_fragment_buf_", nameCounter );
	fragmentBufferHandle = TextureHandle::Create( charbuf, &Texture::CreationStruct( 
		Texture::CF_STRUCTURED_BUFFER | Texture::CF_UAV_COUNTER,
		maxFragments, 0, 
		DXGI_FORMAT_UNKNOWN, 1, sizeof(uint32_t)*4) );

	// --- primitive buffer --- stores data for every primitive hit by the renderer
	// each primitive is 48 bytes
	const int maxPrimitives = 1024 * 1024; // 48 MiB
	sprintf( charbuf, "%s%i", "_primitive_buf_", nameCounter );
	primitiveBufferHandle = TextureHandle::Create( charbuf, &Texture::CreationStruct( 
		Texture::CF_BUFFER | Texture::CF_VERTEX_BUFFER | Texture::CF_STREAM_OUT,
		(maxPrimitives * 48) / 16, 0, DXGI_FORMAT_R32G32B32A32_UINT ) );

	maxSpecialFragmentChains = width * height / 10; // max 10% 'special'
	sprintf( charbuf, "%s%i", "_special_fragment_chains_buf_", nameCounter );
	specialFragmentChainsHandle = TextureHandle::Create( charbuf, &Texture::CreationStruct( 
		Texture::CF_STRUCTURED_BUFFER | Texture::CF_UAV,
		maxSpecialFragmentChains, 0, 
		DXGI_FORMAT_UNKNOWN, 1, sizeof(uint32_t)) );
	sprintf( charbuf, "%s%i", "_span_buffer_data_", nameCounter );
	spanBufferDataHandle = TextureHandle::Create( charbuf, &Texture::CreationStruct( 
		Texture::CF_STRUCTURED_BUFFER | Texture::CF_UAV,
		1, 0, 
		DXGI_FORMAT_UNKNOWN, 1, sizeof(uint32_t)*4) );

	//  head buffer with link per pixel
	sprintf( charbuf, "%s%i", "_fragment_head_", nameCounter );
	fragmentHeadBufferHandle = TextureHandle::Create( charbuf, &Texture::CreationStruct( 
		Texture::CF_UAV,
		width, height, 
		DXGI_FORMAT_R32_UINT ) );

	// used to count fragments chain length per pixel using pixel blending
	sprintf( charbuf, "%s%i", "_fragment_rt_", nameCounter );
	fragmentRTHandle = TextureHandle::Create( charbuf, &Texture::CreationStruct( 
		Texture::CF_RENDER_TARGET,
		width, height, 
		DXGI_FORMAT_R8_UNORM) );
	TexturePtr fragmentRT = fragmentRTHandle->Acquire();
	// create another shader view as uint for reading in the compute shaders
	HRESULT hr;
	D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
	srvDesc.Format = DXGI_FORMAT_R8_UINT;
	srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MipLevels = -1;
	srvDesc.Texture2D.MostDetailedMip = 0;
	DXFAIL( Gfx::Get()->GetDevice()->CreateShaderResourceView( fragmentRT->m_baseTexture, 
													&srvDesc, 
													&fragmentRTUintView ) );

	// used to store min and max depth (R and A)
	sprintf( charbuf, "%s%i", "_fragment_rt2_", nameCounter );
	fragmentRT2Handle = TextureHandle::Create( charbuf, &Texture::CreationStruct( 
		Texture::CF_RENDER_TARGET,
		width, height, 
		DXGI_FORMAT_R16G16B16A16_UNORM) );

	nameCounter++;

	spanBufferShaderHandle = ShaderFXHandle::Load( "initials/spanbuffer" );
	ShaderFXPtr mainEffect = spanBufferShaderHandle->Acquire();
	mainEffect->setUAV( "Fragments", fragmentBufferHandle );
	mainEffect->setUAV( "FragmentHeads", fragmentHeadBufferHandle );

	sortFragmentsShaderHandle = ShaderFXHandle::Load( "compute/sortfragments" );
	ShaderFXPtr sortEffect = sortFragmentsShaderHandle->Acquire();
	sortEffect->setVariable( "fragRT", fragmentRTUintView );
	sortEffect->setVariable( "fragRT2", fragmentRT2Handle );
	sortEffect->setUAV( "Fragments", fragmentBufferHandle );
	sortEffect->setUAV( "FragmentHeads", fragmentHeadBufferHandle );
	sortEffect->setUAV( "specialFragmentsAppender", specialFragmentChainsHandle );
	sortEffect->setUAV( "spanDataBuffer", spanBufferDataHandle );

	sortSpecialFragmentsShaderHandle = ShaderFXHandle::Load( "compute/sortspecialfragments" );
	ShaderFXPtr sortSpecialEffect = sortSpecialFragmentsShaderHandle->Acquire();
	sortSpecialEffect->setVariable( "fragRT", fragmentRTUintView );
	sortSpecialEffect->setVariable( "fragRT2", fragmentRT2Handle );
	sortSpecialEffect->setVariable( "specialFragmentsConsumer", specialFragmentChainsHandle );
	sortSpecialEffect->setUAV( "Fragments", fragmentBufferHandle );
	sortSpecialEffect->setUAV( "FragmentHeads", fragmentHeadBufferHandle );
	sortSpecialEffect->setUAV( "spanDataBuffer", spanBufferDataHandle );

	// debug
	debugHandle = ShaderFXHandle::Load( "debug/debugspanbuffers" );
	ShaderFXPtr debugEffect = debugHandle->Acquire();
	debugEffect->selectGroup( "compute" );
	debugEffect->setUAV( "Fragments", fragmentBufferHandle );
	debugEffect->setUAV( "FragmentHeads", fragmentHeadBufferHandle );
	debugEffect->setVariable( "fragRT", fragmentRTUintView );
	debugEffect->setVariable( "fragRT2", fragmentRT2Handle );

}

SM1view::~SM1view() {
	spanBufferDataHandle->Close();
	debugHandle->Close();
	sortSpecialFragmentsShaderHandle->Close();
	sortFragmentsShaderHandle->Close();
	spanBufferShaderHandle->Close();
	fragmentRT2Handle->Close();
	fragmentRTHandle->Close();
	fragmentHeadBufferHandle->Close();
	primitiveBufferHandle->Close();
	specialFragmentChainsHandle->Close();
	fragmentBufferHandle->Close();
}

void SM1view::startRender( RenderContext* context ) {
	TexturePtr fragmentBuffer = fragmentBufferHandle->Acquire();
	TexturePtr primitiveBuffer = primitiveBufferHandle->Acquire();
	TexturePtr fragmentHeadBuffer = fragmentHeadBufferHandle->Acquire();
	TexturePtr fragmentRT = fragmentRTHandle->Acquire();
	TexturePtr fragmentRT2 = fragmentRT2Handle->Acquire();
	TexturePtr specialFragmentChains = specialFragmentChainsHandle->Acquire();
	TexturePtr spanBufferData = spanBufferDataHandle->Acquire();
	// reset UAV counters
	ID3D11UnorderedAccessView* uavs[] = { 
		(ID3D11UnorderedAccessView*) fragmentBuffer->m_extraView,
	};
	uint32_t counterVals[] = { 0 };
	context->deviceContext->CSSetUnorderedAccessViews(0, 1, uavs, counterVals ); 
	
	// reset all resources and shaders
	void* emptyViews[] = { 0,0,0,0, 0,0,0,0 };
	context->deviceContext->PSSetShader( NULL, NULL, 0 );
	context->deviceContext->CSSetShader( NULL, NULL, 0 );
	context->deviceContext->PSSetShaderResources( 0, 8, (ID3D11ShaderResourceView**) emptyViews );
	context->deviceContext->CSSetShaderResources( 0, 8, (ID3D11ShaderResourceView**) emptyViews );
	context->deviceContext->CSSetUnorderedAccessViews(0, 8, (ID3D11UnorderedAccessView**) emptyViews, NULL ); 
	context->deviceContext->OMSetRenderTargets(8, (ID3D11RenderTargetView**) emptyViews, NULL ); 

	// clear links
	const uint32_t uavClearer0[] = { 0x0, 0x0, 0x0, 0x0 };
	const uint32_t uavClearer[] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
	const float	 rtClearer[] = { 0.0f, 0.0f, 1.0f, 0.0f }; // r = count b = min(z) a=max(z)
	context->deviceContext->ClearUnorderedAccessViewUint( 
					(ID3D11UnorderedAccessView*)fragmentHeadBuffer->m_extraView, uavClearer );
	context->deviceContext->ClearUnorderedAccessViewUint( 
					(ID3D11UnorderedAccessView*)spanBufferData->m_extraView, uavClearer0 );
	context->deviceContext->ClearRenderTargetView( 
					(ID3D11RenderTargetView*) fragmentRT->m_extraView, rtClearer );
	context->deviceContext->ClearRenderTargetView( 
					(ID3D11RenderTargetView*) fragmentRT2->m_extraView, rtClearer );

	// initial render pass state and shaders set into hardware
	TexturePtr targets[] = { fragmentRT, fragmentRT2 };
	context->useRenderTargets( 2,  targets, NULL );
	ID3D11Buffer* soBuffers[] = { (ID3D11Buffer*) primitiveBuffer->m_baseTexture };
	uint32_t soOffsets[] = { 0 };
	context->deviceContext->SOSetTargets( 1, soBuffers, soOffsets );
	ShaderFXPtr defaultState = spanBufferShaderHandle->Acquire();
	defaultState->m_pEffectTechnique->GetPassByIndex( 0 )->Apply( 0,  context->deviceContext );
	VDeclManager::SetReferenceShader( spanBufferShaderHandle );
	context->setReferenceShader( spanBufferShaderHandle->Acquire() );
}

void SM1view::endRender( RenderContext* context ) {

	void* emptyViews[] = { 0,0,0,0, 0,0,0,0 };
	context->deviceContext->PSSetShaderResources( 0, 8, (ID3D11ShaderResourceView**) emptyViews );
	context->deviceContext->CSSetUnorderedAccessViews(0, 8, (ID3D11UnorderedAccessView**) emptyViews, NULL ); 
	context->deviceContext->SOSetTargets( 1, (ID3D11Buffer**) emptyViews, (uint32_t*)emptyViews );
	Gfx::Get()->resetToDefaultRenderTargets();

	const unsigned int groupsX = width / 16;
	const unsigned int groupsY = height / 16;

	// sort fragments
	TexturePtr specialFragmentChains = specialFragmentChainsHandle->Acquire();
	ShaderFXPtr effect = sortFragmentsShaderHandle->Acquire();
	ShaderFXPtr specialEffect = sortSpecialFragmentsShaderHandle->Acquire();
	// has two passes, a fast general one, than a slower special fragment handler
	// 1st is run in 256 thread group across the screen

	effect->m_pEffectTechnique->GetPassByIndex( 0 )->Apply( 0, context->deviceContext );
	context->deviceContext->Dispatch( groupsX, groupsY, 1 );

	context->deviceContext->CSSetShaderResources( 0, 8, (ID3D11ShaderResourceView**) emptyViews );
	context->deviceContext->CSSetUnorderedAccessViews(0, 8, (ID3D11UnorderedAccessView**) emptyViews, NULL ); 
	specialEffect->m_pEffectTechnique->GetPassByIndex( 0 )->Apply( 0, context->deviceContext );

	const unsigned int specialGroupsX = (maxSpecialFragmentChains+63)/64;
	context->deviceContext->Dispatch( specialGroupsX, 1, 1 );

	context->deviceContext->CSSetShaderResources( 0, 8, (ID3D11ShaderResourceView**) emptyViews );
	context->deviceContext->CSSetUnorderedAccessViews(0, 8, (ID3D11UnorderedAccessView**) emptyViews, NULL ); 

}


void SM1view::debugDraw( RenderContext* context, D3D11UnorderedAccessViewSmartPtr rt ) {
	ShaderFXPtr effect = debugHandle->Acquire();

	void* emptyViews[] = { 0,0,0,0, 0,0,0,0 };
	context->deviceContext->PSSetShaderResources( 0, 8, (ID3D11ShaderResourceView**) emptyViews );
	context->deviceContext->CSSetUnorderedAccessViews(0, 8, (ID3D11UnorderedAccessView**) emptyViews, NULL ); 

	Gfx::Get()->resetToDefaultRenderTargets();
	effect->setUAV( "resultColourBuffer", rt );

	const unsigned int groupsX = width / 16;
	const unsigned int groupsY = height / 16;

	D3DX11_TECHNIQUE_DESC techDesc;
	effect->m_pEffectTechnique->GetDesc( &techDesc );
	for( uint32_t i = 0;i < techDesc.Passes;++i) {
		effect->m_pEffectTechnique->GetPassByIndex( i )->Apply( 0,  Gfx::Get()->GetMainContext() );
		context->deviceContext->Dispatch( groupsX, groupsY, 1 );
	}

	context->deviceContext->PSSetShaderResources( 0, 8, (ID3D11ShaderResourceView**) emptyViews );
	context->deviceContext->CSSetUnorderedAccessViews(0, 8, (ID3D11UnorderedAccessView**) emptyViews, NULL ); 
}

}