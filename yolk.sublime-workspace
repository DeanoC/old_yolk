{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"engine",
				"engineBuilder"
			],
			[
				"engin",
				"engineBuilder"
			],
			[
				"aab",
				"aabbStack"
			],
			[
				"aa",
				"aabbStack"
			],
			[
				"_cu",
				"_cullFunc"
			],
			[
				"get",
				"getHalfLength"
			],
			[
				"CULL",
				"CULL_FUNC_RETURN"
			],
			[
				"tra",
				"TransformNode"
			],
			[
				"Tree",
				"TreePhysical"
			],
			[
				"Tr",
				"TreePhysicalPtr"
			],
			[
				"getC",
				"getBoxCenter"
			],
			[
				"on",
				"onlyChildNode"
			],
			[
				"T",
				"TileNodeAndAABB"
			],
			[
				"free",
				"freeHead"
			],
			[
				"fre",
				"freeHead"
			],
			[
				"node",
				"nodeATileIndex"
			],
			[
				"nodeB",
				"nodeBTileIndex"
			],
			[
				"til",
				"nodeTileIndex"
			],
			[
				"unp",
				"unpackedNodeA"
			],
			[
				"chil",
				"childBearing"
			],
			[
				"has",
				"hasChildren"
			],
			[
				"nodeA",
				"nodeAIndex"
			],
			[
				"getChildr",
				"getChildrenTileIndex"
			],
			[
				"lea",
				"leafBrickAOccupancy"
			],
			[
				"occ",
				"occupancy"
			],
			[
				"fal",
				"falseBrickIndex"
			],
			[
				"pac",
				"packedBinaryLeaf"
			],
			[
				"BIN",
				"PACKED_BINARY_LEAF"
			],
			[
				"con",
				"constantLeaf"
			],
			[
				"leafBr",
				"leafBrickA"
			],
			[
				"br",
				"brickIndex"
			],
			[
				"emp",
				"emptyCount"
			],
			[
				"leaf",
				"leafBrickB"
			],
			[
				"bri",
				"brickIndex"
			],
			[
				"no",
				"nodeTileIndex"
			],
			[
				"NodeT",
				"NodeTile"
			],
			[
				"Pack",
				"packNode"
			],
			[
				"pa",
				"parentNode"
			],
			[
				"_b",
				"_brickIndex"
			],
			[
				"CO",
				"CONSTANT_LEAF"
			],
			[
				"bo",
				"boundingBox"
			],
			[
				"brick",
				"brickIndex"
			],
			[
				"tile",
				"tileIndex"
			],
			[
				"getN",
				"getNodeTile"
			],
			[
				"Node",
				"NodeType"
			],
			[
				"m_M",
				"m_MaxExtent"
			],
			[
				"spl",
				"splitable"
			],
			[
				"Br",
				"BrickIndex"
			],
			[
				"INTE",
				"INDEX_TYPE"
			],
			[
				"cur",
				"currentFree"
			],
			[
				"cap",
				"capacity"
			],
			[
				"ca",
				"capacityCount"
			],
			[
				"Proto",
				"ProtoQID"
			],
			[
				"uin",
				"uint32_t"
			],
			[
				"uint",
				"uint64_t"
			],
			[
				"Pro",
				"ProtoFID"
			],
			[
				"Pr",
				"ProtoHeader"
			],
			[
				"Prot",
				"ProtoQID"
			],
			[
				"P",
				"ProtoFID"
			],
			[
				"n",
				"namespace"
			],
			[
				"plat",
				"platform_posix"
			],
			[
				"pl",
				"platform_header_files"
			],
			[
				"PL",
				"platform_windows"
			],
			[
				"HEADLESS",
				"headless"
			],
			[
				"tim",
				"timespec"
			],
			[
				"st",
				"startOfTime"
			],
			[
				"pth",
				"pthread_mutex_unlock"
			],
			[
				"Stor",
				"StorageDeviceBase"
			],
			[
				"Movi",
				"MovieClip"
			],
			[
				"Swf",
				"SwfMan"
			],
			[
				"CVN_M",
				"CVN_MATERIAL_INDEX"
			],
			[
				"en",
				"EnemyThingComponent"
			],
			[
				"Gen",
				"GenericMarkerVector"
			],
			[
				"wo",
				"worldTrans"
			],
			[
				"Text",
				"TextureHandle"
			],
			[
				"Re",
				"RenderTargetStates"
			],
			[
				"D3D11_DEP",
				"D3D11_DEPTH_WRITE_MAKE_ALL"
			],
			[
				"de",
				"DepthStencilState"
			],
			[
				"De",
				"DepthStencilState"
			],
			[
				"D3D11_",
				"D3D11_FILL_LINE"
			],
			[
				"inter",
				"internalPreCreate"
			],
			[
				"Wo",
				"WobFileHeader"
			],
			[
				"Sampler",
				"SamplerStates"
			],
			[
				"TW",
				"TWE_RED"
			],
			[
				"MAX_",
				"MAX_RENDER_TARGETS"
			],
			[
				"der",
				"derivedOnly"
			],
			[
				"rende",
				"renderThreadId"
			],
			[
				"Thr",
				"thread_id"
			],
			[
				"ren",
				"renderLoaderImpl"
			],
			[
				"loaderThrea",
				"loaderThreadId"
			],
			[
				"this",
				"this_thread"
			],
			[
				"ac",
				"acquirePumps"
			],
			[
				"internal",
				"internalPumpAcquirePump"
			],
			[
				"pu",
				"push_back"
			],
			[
				"Ac",
				"AcquirePumpCallback"
			],
			[
				"C",
				"CreationStruct"
			],
			[
				"Te",
				"TextureAtlas"
			],
			[
				"in",
				"internalLoad"
			],
			[
				"sh",
				"shared_ptr"
			],
			[
				"Res",
				"ResourceLoader"
			],
			[
				"USE_",
				"USE_DX11"
			],
			[
				"Get",
				"GetBufferPointer"
			],
			[
				"tmp",
				"tmpFragments"
			],
			[
				"out",
				"outsrc"
			],
			[
				"hea",
				"headerStack"
			],
			[
				"ref",
				"referenceTex"
			],
			[
				"pre",
				"prefillPitch"
			],
			[
				"samp",
				"sampleCount"
			],
			[
				"pref",
				"prefillData"
			],
			[
				"view",
				"viewType"
			],
			[
				"GTF_DEPTH",
				"GTF_DEPTH_COMPONENT32F"
			],
			[
				"mip",
				"mipLevels"
			],
			[
				"sl",
				"slices"
			],
			[
				"CPU",
				"CPUAccessFlags"
			],
			[
				"RESOU",
				"RESOURCE_CREATION_FLAGS"
			],
			[
				"sam",
				"sampleCount"
			],
			[
				"D3D11_CP",
				"D3D11_CPU_ACCESS_WRITE"
			],
			[
				"cpu",
				"cpuAccess"
			],
			[
				"D3DD",
				"D3D11_USAGE_DYNAMIC"
			],
			[
				"D3",
				"D3D11_MAP_WRITE_NO_OVERWRITE"
			],
			[
				"D3D11",
				"D3D11_MAP_WRITE"
			],
			[
				"render",
				"renderer"
			],
			[
				"START_F",
				"START_FLAGS"
			],
			[
				"Scre",
				"ScreenPtr"
			],
			[
				"SCRF_",
				"SCRF_DEPTH"
			],
			[
				"GL_",
				"GL_BGRA"
			],
			[
				"GL_M",
				"GL_MAP_READ_BIT"
			],
			[
				"blo",
				"blockHandles"
			]
		]
	},
	"buffers":
	[
		{
			"file": "src/apps/convert/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 838,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "// half - IEEE 754-based half-precision floating point library.\n//\n// Copyright (c) 2012-2013 Christian Rau <rauy@users.sourceforge.net>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation \n// files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, \n// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the \n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE \n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR \n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, \n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Version 1.11.0\n\n/// \\file\n/// Main header file for half precision functionality.\n\n#ifndef HALF_HALF_HPP\n#define HALF_HALF_HPP\n\n/// Combined gcc version number.\n#define HALF_GNUC_VERSION (__GNUC__*100+__GNUC_MINOR__)\n\n//check C++11 language features\n#if defined(__clang__)										//clang\n	#if __has_feature(cxx_static_assert) && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)\n		#define HALF_ENABLE_CPP11_STATIC_ASSERT 1\n	#endif\n	#if __has_feature(cxx_constexpr) && !defined(HALF_ENABLE_CPP11_CONSTEXPR)\n		#define HALF_ENABLE_CPP11_CONSTEXPR 1\n	#endif\n	#if __has_feature(cxx_noexcept) && !defined(HALF_ENABLE_CPP11_NOEXCEPT)\n		#define HALF_ENABLE_CPP11_NOEXCEPT 1\n	#endif\n	#if __has_feature(cxx_user_literals) && !defined(HALF_ENABLE_CPP11_USER_LITERALS)\n		#define HALF_ENABLE_CPP11_USER_LITERALS 1\n	#endif\n	#if (defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L) && !defined(HALF_ENABLE_CPP11_LONG_LONG)\n		#define HALF_ENABLE_CPP11_LONG_LONG 1\n	#endif\n/*#elif defined(__INTEL_COMPILER)								//Intel C++\n	#if __INTEL_COMPILER >= 1100 && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)		????????\n		#define HALF_ENABLE_CPP11_STATIC_ASSERT 1\n	#endif\n	#if __INTEL_COMPILER >= 1300 && !defined(HALF_ENABLE_CPP11_CONSTEXPR)			????????\n		#define HALF_ENABLE_CPP11_CONSTEXPR 1\n	#endif\n	#if __INTEL_COMPILER >= 1300 && !defined(HALF_ENABLE_CPP11_NOEXCEPT)			????????\n		#define HALF_ENABLE_CPP11_NOEXCEPT 1\n	#endif\n	#if __INTEL_COMPILER >= 1100 && !defined(HALF_ENABLE_CPP11_LONG_LONG)			????????\n		#define HALF_ENABLE_CPP11_LONG_LONG 1\n	#endif*/\n#elif defined(__GNUC__)										//gcc\n	#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L\n		#if HALF_GNUC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)\n			#define HALF_ENABLE_CPP11_STATIC_ASSERT 1\n		#endif\n		#if HALF_GNUC_VERSION >= 406 && !defined(HALF_ENABLE_CPP11_CONSTEXPR)\n			#define HALF_ENABLE_CPP11_CONSTEXPR 1\n		#endif\n		#if HALF_GNUC_VERSION >= 406 && !defined(HALF_ENABLE_CPP11_NOEXCEPT)\n			#define HALF_ENABLE_CPP11_NOEXCEPT 1\n		#endif\n		#if HALF_GNUC_VERSION >= 407 && !defined(HALF_ENABLE_CPP11_USER_LITERALS)\n			#define HALF_ENABLE_CPP11_USER_LITERALS 1\n		#endif\n		#if !defined(HALF_ENABLE_CPP11_LONG_LONG)\n			#define HALF_ENABLE_CPP11_LONG_LONG 1\n		#endif\n	#endif\n#elif defined(_MSC_VER)										//Visual C++\n	#if _MSC_VER >= 1600 && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)\n		#define HALF_ENABLE_CPP11_STATIC_ASSERT 1\n	#endif\n	#if _MSC_VER >= 1310 && !defined(HALF_ENABLE_CPP11_LONG_LONG)\n		#define HALF_ENABLE_CPP11_LONG_LONG 1\n	#endif\n	#define HALF_POP_WARNINGS 1\n	#pragma warning(push)\n	#pragma warning(disable : 4099 4127 4146)	//struct vs class, constant in if, negative unsigned\n#endif\n\n//check C++11 library features\n#include <utility>\n#if defined(_LIBCPP_VERSION)								//libc++\n	#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103\n		#ifndef HALF_ENABLE_CPP11_TYPE_TRAITS\n			#define HALF_ENABLE_CPP11_TYPE_TRAITS 1\n		#endif\n		#ifndef HALF_ENABLE_CPP11_CSTDINT\n			#define HALF_ENABLE_CPP11_CSTDINT 1\n		#endif\n		#ifndef HALF_ENABLE_CPP11_CMATH\n			#define HALF_ENABLE_CPP11_CMATH 1\n		#endif\n		#ifndef HALF_ENABLE_CPP11_HASH\n			#define HALF_ENABLE_CPP11_HASH 1\n		#endif\n	#endif\n#elif defined(__GLIBCXX__)									//libstdc++\n	#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103\n		#ifdef __clang__\n			#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_TYPE_TRAITS)\n				#define HALF_ENABLE_CPP11_TYPE_TRAITS 1\n			#endif\n			#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_CSTDINT)\n				#define HALF_ENABLE_CPP11_CSTDINT 1\n			#endif\n			#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_CMATH)\n				#define HALF_ENABLE_CPP11_CMATH 1\n			#endif\n			#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_HASH)\n				#define HALF_ENABLE_CPP11_HASH 1\n			#endif\n		#else\n			#if HALF_GNUC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_CSTDINT)\n				#define HALF_ENABLE_CPP11_CSTDINT 1\n			#endif\n			#if HALF_GNUC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_CMATH)\n				#define HALF_ENABLE_CPP11_CMATH 1\n			#endif\n			#if HALF_GNUC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_HASH)\n				#define HALF_ENABLE_CPP11_HASH 1\n			#endif\n		#endif\n	#endif\n#elif defined(_CPPLIB_VER)									//Dinkumware/Visual C++\n	#if _CPPLIB_VER >= 520\n		#ifndef HALF_ENABLE_CPP11_TYPE_TRAITS\n			#define HALF_ENABLE_CPP11_TYPE_TRAITS 1\n		#endif\n		#ifndef HALF_ENABLE_CPP11_CSTDINT\n			#define HALF_ENABLE_CPP11_CSTDINT 1\n		#endif\n		#ifndef HALF_ENABLE_CPP11_HASH\n			#define HALF_ENABLE_CPP11_HASH 1\n		#endif\n	#endif\n	#if _CPPLIB_VER >= 610\n		#ifndef HALF_ENABLE_CPP11_CMATH\n			#define HALF_ENABLE_CPP11_CMATH 1\n		#endif\n	#endif\n#endif\n#undef HALF_GNUC_VERSION\n\n//support constexpr\n#if HALF_ENABLE_CPP11_CONSTEXPR\n	#define HALF_CONSTEXPR			constexpr\n	#define HALF_CONSTEXPR_CONST	constexpr\n#else\n	#define HALF_CONSTEXPR\n	#define HALF_CONSTEXPR_CONST	const\n#endif\n\n//support noexcept\n#if HALF_ENABLE_CPP11_NOEXCEPT\n	#define HALF_NOEXCEPT	noexcept\n	#define HALF_NOTHROW	noexcept\n#else\n	#define HALF_NOEXCEPT\n	#define HALF_NOTHROW	throw()\n#endif\n\n#include <algorithm>\n#include <iostream>\n#include <limits>\n#include <climits>\n#include <cmath>\n#include <cstring>\n#if HALF_ENABLE_CPP11_TYPE_TRAITS\n	#include <type_traits>\n#endif\n#if HALF_ENABLE_CPP11_CSTDINT\n	#include <cstdint>\n#endif\n#if HALF_ENABLE_CPP11_HASH\n	#include <functional>\n#endif\n\n\n/// Default rounding mode.\n/// This specifies the rounding mode used for all conversions between [half](\\ref half_float::half)s and `float`s as well as \n/// for the half_cast() if not specifying a rounding mode explicitly. It can be redefined (before including half.hpp) to one \n/// of the standard rounding modes using their respective constants or the equivalent values of `std::float_round_style`:\n///\n/// `std::float_round_style`         | value | rounding\n/// ---------------------------------|-------|-------------------------\n/// `std::round_indeterminate`       | -1    | fastest (default)\n/// `std::round_toward_zero`         | 0     | toward zero\n/// `std::round_to_nearest`          | 1     | to nearest\n/// `std::round_toward_infinity`     | 2     | toward positive infinity\n/// `std::round_toward_neg_infinity` | 3     | toward negative infinity\n///\n/// By default this is set to `-1` (`std::round_indeterminate`), which uses truncation (round toward zero, but with overflows \n/// set to infinity) and is the fastest rounding mode possible. It can even be set to `std::numeric_limits<float>::round_style` \n/// to synchronize the rounding mode with that of the underlying single-precision implementation.\n#ifndef HALF_ROUND_STYLE\n	#define HALF_ROUND_STYLE	-1			// = std::round_indeterminate\n#endif\n\n/// Tie-breaking behaviour for round to nearest.\n/// This specifies if ties in round to nearest should be resolved by rounding to the nearest even value. By default this is \n/// defined to `0` resulting in the faster but slightly more biased behaviour of rounding away from zero in half-way cases (and \n/// thus equal to the round() function), but can be redefined to `1` (before including half.hpp) if more IEEE-conformant \n/// behaviour is needed.\n#ifndef HALF_ROUND_TIES_TO_EVEN\n	#define HALF_ROUND_TIES_TO_EVEN	0		// ties away from zero\n#endif\n\n/// Value signaling overflow.\n/// In correspondence with `HUGE_VAL[F|L]` from `<cmath>` this symbol expands to a positive value signaling the overflow of an \n/// operation, in particular it just evaluates to positive infinity.\n#define HUGE_VALH	std::numeric_limits<half_float::half>::infinity()\n\n/// Fast half-precision fma function.\n/// This symbol is only defined if the fma() function generally executes as fast as, or faster than, a separate \n/// half-precision multiplication followed by an addition. Due to the internal single-precision implementation of all \n/// arithmetic operations, this is in fact always the case.\n#define FP_FAST_FMAH	1\n\n#ifndef FP_ILOGB0\n	#define FP_ILOGB0		INT_MIN\n#endif\n#ifndef FP_ILOGBNAN\n	#define FP_ILOGBNAN		INT_MAX\n#endif\n#ifndef FP_SUBNORMAL\n	#define FP_SUBNORMAL	0\n#endif\n#ifndef FP_ZERO\n	#define FP_ZERO			1\n#endif\n#ifndef FP_NAN\n	#define FP_NAN			2\n#endif\n#ifndef FP_INFINITE\n	#define FP_INFINITE		3\n#endif\n#ifndef FP_NORMAL\n	#define FP_NORMAL		4\n#endif\n\n\n/// Main namespace for half precision functionality.\n/// This namespace contains all the functionality provided by the library.\nnamespace half_float\n{\n	class half;\n\n	/// \\internal\n	/// \\brief Implementation details.\n	namespace detail\n	{\n	#if HALF_ENABLE_CPP11_TYPE_TRAITS\n		/// Conditional type.\n		template<bool B,typename T,typename F> struct conditional : std::conditional<B,T,F> {};\n\n		/// Helper for tag dispatching.\n		template<bool B> struct bool_type : std::integral_constant<bool,B> {};\n		using std::true_type;\n		using std::false_type;\n\n		/// Type traits for floating point types.\n		template<typename T> struct is_float : std::is_floating_point<T> {};\n	#else\n		/// Conditional type.\n		template<bool,typename T,typename> struct conditional { typedef T type; };\n		template<typename T,typename F> struct conditional<false,T,F> { typedef F type; };\n\n		/// Helper for tag dispatching.\n		template<bool> struct bool_type {};\n		typedef bool_type<true> true_type;\n		typedef bool_type<false> false_type;\n\n		/// Type traits for floating point types.\n		template<typename> struct is_float : false_type {};\n		template<typename T> struct is_float<const T> : is_float<T> {};\n		template<typename T> struct is_float<volatile T> : is_float<T> {};\n		template<typename T> struct is_float<const volatile T> : is_float<T> {};\n		template<> struct is_float<float> : true_type {};\n		template<> struct is_float<double> : true_type {};\n		template<> struct is_float<long double> : true_type {};\n	#endif\n\n	#if HALF_ENABLE_CPP11_CSTDINT\n		/// Unsigned integer of (at least) 16 bits width.\n		typedef std::uint_least16_t uint16;\n\n		/// Unsigned integer of (at least) 32 bits width.\n		typedef std::uint_least32_t uint32;\n\n		/// Fastest signed integer capable of holding all values of type uint16.\n		typedef std::int_fast32_t int17;\n	#else\n		/// Unsigned integer of (at least) 16 bits width.\n		typedef unsigned short uint16;\n\n		/// Unsigned integer of (at least) 32 bits width.\n		typedef conditional<std::numeric_limits<unsigned int>::digits>=32,unsigned int,unsigned long>::type uint32;\n\n		/// Fastest signed integer capable of holding all values of type uint16.\n		typedef conditional<std::numeric_limits<int>::digits>=16,int,long>::type int17;\n	#endif\n\n		/// Tag type for binary construction.\n		struct binary_t {};\n\n		/// Tag for binary construction.\n		HALF_CONSTEXPR_CONST binary_t binary = binary_t();\n\n		/// Temporary half-precision expression.\n		/// This class represents a half-precision expression which just stores a single-precision value internally.\n		struct expr\n		{\n			/// Conversion constructor.\n			/// \\param f single-precision value to convert\n			explicit HALF_CONSTEXPR expr(float f) : value_(f) {}\n\n			/// Conversion to single-precision.\n			/// \\return single precision value representing expression value\n			HALF_CONSTEXPR operator float() const { return value_; }\n\n		private:\n			/// Internal expression value stored in single-precision.\n			float value_;\n		};\n\n		/// SFINAE helper for generic half-precision functions.\n		/// This class template has to be specialized for each valid combination of argument types to provide a corresponding \n		/// `type` member equivalent to \\a T.\n		/// \\tparam T type to return\n		template<typename T,typename,typename=void,typename=void> struct enable {};\n		template<typename T> struct enable<T,half,void,void> { typedef T type; };\n		template<typename T> struct enable<T,expr,void,void> { typedef T type; };\n		template<typename T> struct enable<T,half,half,void> { typedef T type; };\n		template<typename T> struct enable<T,half,expr,void> { typedef T type; };\n		template<typename T> struct enable<T,expr,half,void> { typedef T type; };\n		template<typename T> struct enable<T,expr,expr,void> { typedef T type; };\n		template<typename T> struct enable<T,half,half,half> { typedef T type; };\n		template<typename T> struct enable<T,half,half,expr> { typedef T type; };\n		template<typename T> struct enable<T,half,expr,half> { typedef T type; };\n		template<typename T> struct enable<T,half,expr,expr> { typedef T type; };\n		template<typename T> struct enable<T,expr,half,half> { typedef T type; };\n		template<typename T> struct enable<T,expr,half,expr> { typedef T type; };\n		template<typename T> struct enable<T,expr,expr,half> { typedef T type; };\n		template<typename T> struct enable<T,expr,expr,expr> { typedef T type; };\n\n		/// Return type for specialized generic 2-argument half-precision functions.\n		/// This class template has to be specialized for each valid combination of argument types to provide a corresponding \n		/// `type` member denoting the appropriate return type.\n		/// \\tparam T first argument type\n		/// \\tparam U first argument type\n		template<typename T,typename U> struct result : enable<expr,T,U> {};\n		template<> struct result<half,half> { typedef half type; };\n\n		/// \\name Classification helpers\n		/// \\{\n\n		/// Check for infinity.\n		/// \\tparam T argument type (builtin floating point type)\n		/// \\param arg value to query\n		/// \\retval true if infinity\n		/// \\retval false else\n		template<typename T> bool builtin_isinf(T arg)\n		{\n		#if HALF_ENABLE_CPP11_CMATH\n			return std::isinf(arg);\n		#elif defined(_MSC_VER)\n			return !_finite(static_cast<double>(arg)) && !_isnan(static_cast<double>(arg));\n		#else\n			return arg == std::numeric_limits<T>::infinity() || arg == -std::numeric_limits<T>::infinity();\n		#endif\n		}\n\n		/// Check for NaN.\n		/// \\tparam T argument type (builtin floating point type)\n		/// \\param arg value to query\n		/// \\retval true if not a number\n		/// \\retval false else\n		template<typename T> bool builtin_isnan(T arg)\n		{\n		#if HALF_ENABLE_CPP11_CMATH\n			return std::isnan(arg);\n		#elif defined(_MSC_VER)\n			return _isnan(static_cast<double>(arg)) != 0;\n		#else\n			return arg != arg;\n		#endif\n		}\n\n		/// Check sign.\n		/// \\tparam T argument type (builtin floating point type)\n		/// \\param arg value to query\n		/// \\retval true if signbit set\n		/// \\retval false else\n		template<typename T> bool builtin_signbit(T arg)\n		{\n		#if HALF_ENABLE_CPP11_CMATH\n			return std::signbit(arg);\n		#else\n			return arg < T() || (arg == T() && T(1)/arg < T());\n		#endif\n		}\n\n		/// \\}\n		/// \\name Conversion\n		/// \\{\n\n		/// Convert IEEE single-precision to half-precision.\n		/// Credit for this goes to [Jeroen van der Zijp](ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf).\n		/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n		/// \\param value single-precision value\n		/// \\return binary representation of half-precision value\n		template<std::float_round_style R> uint16 float2half_impl(float value, true_type)\n		{\n		#if HALF_ENABLE_CPP11_STATIC_ASSERT\n			static_assert(std::numeric_limits<float>::is_iec559, \"float to half conversion needs IEEE 754 conformant 'float' type\");\n			static_assert(sizeof(uint32)==sizeof(float), \"float to half conversion needs unsigned integer type of exactly the size of a 'float'\");\n		#endif\n			static const uint16 base_table[512] = { \n				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n				0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100, \n				0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00, \n				0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00, \n				0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n				0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n				0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n				0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n				0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n				0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n				0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n				0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100, \n				0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00, \n				0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00, \n				0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n				0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n				0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n				0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n				0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n				0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n				0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };\n			static const unsigned char shift_table[512] = { \n				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n				24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, \n				13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13, \n				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n				24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, \n				13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n				24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };\n			uint32 bits;// = *reinterpret_cast<uint32*>(&value);		//violating strict aliasing!\n			std::memcpy(&bits, &value, sizeof(float));\n			uint16 hbits = base_table[bits>>23] + static_cast<uint16>((bits&0x7FFFFF)>>shift_table[bits>>23]);\n			if(R == std::round_to_nearest)\n				hbits += (((bits&0x7FFFFF)>>(shift_table[bits>>23]-1))|(((bits>>23)&0xFF)==102)) & ((hbits&0x7C00)!=0x7C00)\n				#if HALF_ROUND_TIES_TO_EVEN\n					& (((((static_cast<uint32>(1)<<(shift_table[bits>>23]-1))-1)&bits)!=0)|hbits)\n				#endif\n				;\n			else if(R == std::round_toward_zero)\n				hbits -= ((hbits&0x7FFF)==0x7C00) & ~shift_table[bits>>23];\n			else if(R == std::round_toward_infinity)\n				hbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=102)&\n					((bits>>23)!=0)))&(hbits<0x7C00)) - ((hbits==0xFC00)&((bits>>23)!=511));\n			else if(R == std::round_toward_neg_infinity)\n				hbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=358)&\n					((bits>>23)!=256)))&(hbits<0xFC00)&(hbits>>15)) - ((hbits==0x7C00)&((bits>>23)!=255));\n			return hbits;\n		}\n\n		/// Convert non-IEEE single-precision to half-precision.\n		/// \\param value single-precision value\n		/// \\return binary representation of half-precision value\n		template<std::float_round_style R> uint16 float2half_impl(float value, false_type)\n		{\n			uint16 hbits = builtin_signbit(value) << 15;\n			if(value == 0.0f)\n				return hbits;\n			if(builtin_isnan(value))\n				return hbits | 0x7FFF;\n			if(builtin_isinf(value))\n				return hbits | 0x7C00;\n			int exp;\n			std::frexp(value, &exp);\n			if(exp > 16)\n			{\n				if(R == std::round_toward_zero)\n					return hbits | 0x7BFF;\n				else if(R == std::round_toward_infinity)\n					return hbits | 0x7C00 - (hbits>>15);\n				else if(R == std::round_toward_neg_infinity)\n					return hbits | 0x7BFF + (hbits>>15);\n				return hbits | 0x7C00;\n			}\n			if(exp < -13)\n				value = std::ldexp(value, 24);\n			else\n			{\n				value = std::ldexp(value, 11-exp);\n				hbits |= ((exp+14)<<10);\n			}\n			int ival = static_cast<int>(value);\n			hbits |= static_cast<uint16>(std::abs(ival)&0x3FF);\n			if(R == std::round_to_nearest)\n			{\n				float diff = std::abs(value-static_cast<float>(ival));\n				#if HALF_ROUND_TIES_TO_EVEN\n					hbits += (diff>0.5f) | ((diff==0.5f)&hbits);\n				#else\n					hbits += diff >= 0.5f;\n				#endif\n			}\n			else if(R == std::round_toward_infinity)\n				hbits += value > static_cast<float>(ival);\n			else if(R == std::round_toward_neg_infinity)\n				hbits += value < static_cast<float>(ival);\n			return hbits;\n		}\n\n		/// Convert single-precision to half-precision.\n		/// \\param value single-precision value\n		/// \\return binary representation of half-precision value\n		template<std::float_round_style R> uint16 float2half(float value)\n		{\n			return float2half_impl<R>(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());\n		}\n\n		/// Convert integer to half-precision floating point.\n		/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n		/// \\tparam S `true` if value negative, `false` else\n		/// \\tparam T type to convert (builtin integer type)\n		/// \\param value non-negative integral value\n		/// \\return binary representation of half-precision value\n		template<std::float_round_style R,bool S,typename T> uint16 int2half_impl(T value)\n		{\n			if(S)\n				value = -value;\n			uint16 bits = S << 15;\n			if(value > 65504)\n			{\n				if(R == std::round_toward_infinity)\n					bits |= 0x7C00 - S;\n				else if(R == std::round_toward_neg_infinity)\n					bits |= 0x7BFF + S;\n				else\n					bits |= 0x7BFF + (R!=std::round_toward_zero);\n			}\n			else if(value)\n			{\n				unsigned int m = value, exp = 25;\n				for(; m<0x400; m<<=1,--exp) ;\n				for(; m>0x7FF; m>>=1,++exp) ;\n				bits |= (exp<<10) | (m&0x3FF);\n				if(exp > 25)\n				{\n					if(R == std::round_to_nearest)\n						bits += (value>>(exp-26)) & 1\n						#if HALF_ROUND_TIES_TO_EVEN\n							& (((((1<<(exp-26))-1)&value)!=0)|bits)\n						#endif\n						;\n					else if(R == std::round_toward_infinity)\n						bits += ((value&((1<<(exp-25))-1))!=0) & !S;\n					else if(R == std::round_toward_neg_infinity)\n						bits += ((value&((1<<(exp-25))-1))!=0) & S;\n				}\n			}\n			return bits;\n		}\n\n		/// Convert integer to half-precision floating point.\n		/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n		/// \\tparam T type to convert (builtin integer type)\n		/// \\param value integral value\n		/// \\return binary representation of half-precision value\n		template<std::float_round_style R,typename T> uint16 int2half(T value)\n		{\n			return (value<0) ? int2half_impl<R,true>(value) : int2half_impl<R,false>(value);\n		}\n\n		/// Convert half-precision to IEEE single-precision.\n		/// Credit for this goes to [Jeroen van der Zijp](ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf).\n		/// \\param value binary representation of half-precision value\n		/// \\return single-precision value\n		inline float half2float_impl(uint16 value, true_type)\n		{\n		#if HALF_ENABLE_CPP11_STATIC_ASSERT\n			static_assert(std::numeric_limits<float>::is_iec559, \"half to float conversion needs IEEE 754 conformant 'float' type\");\n			static_assert(sizeof(uint32)==sizeof(float), \"half to float conversion needs unsigned integer type of exactly the size of a 'float'\");\n		#endif\n			static const uint32 mantissa_table[2048] = { \n				0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000, \n				0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000, \n				0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000, \n				0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000, \n				0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000, \n				0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000, \n				0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000, \n				0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000, \n				0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000, \n				0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000, \n				0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000, \n				0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000, \n				0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000, \n				0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000, \n				0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000, \n				0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000, \n				0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000, \n				0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000, \n				0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000, \n				0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000, \n				0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000, \n				0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000, \n				0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000, \n				0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000, \n				0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000, \n				0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000, \n				0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000, \n				0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000, \n				0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000, \n				0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000, \n				0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000, \n				0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000, \n				0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000, \n				0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000, \n				0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000, \n				0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000, \n				0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000, \n				0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000, \n				0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000, \n				0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000, \n				0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000, \n				0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000, \n				0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000, \n				0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000, \n				0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000, \n				0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000, \n				0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000, \n				0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000, \n				0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000, \n				0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000, \n				0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000, \n				0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000, \n				0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000, \n				0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000, \n				0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000, \n				0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000, \n				0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000, \n				0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000, \n				0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000, \n				0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000, \n				0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000, \n				0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000, \n				0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000, \n				0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000, \n				0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000, \n				0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000, \n				0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000, \n				0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000, \n				0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000, \n				0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000, \n				0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000, \n				0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000, \n				0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000, \n				0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000, \n				0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000, \n				0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000, \n				0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000, \n				0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000, \n				0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000, \n				0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000, \n				0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000, \n				0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000, \n				0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000, \n				0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000, \n				0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000, \n				0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000, \n				0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000, \n				0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000, \n				0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000, \n				0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000, \n				0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000, \n				0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000, \n				0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000, \n				0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000, \n				0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000, \n				0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000, \n				0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000, \n				0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000, \n				0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000, \n				0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000, \n				0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000, \n				0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000, \n				0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000, \n				0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000, \n				0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000, \n				0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000, \n				0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000, \n				0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000, \n				0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000, \n				0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000, \n				0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000, \n				0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000, \n				0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000, \n				0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000, \n				0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000, \n				0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000, \n				0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000, \n				0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000, \n				0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000, \n				0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000, \n				0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000, \n				0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000, \n				0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000, \n				0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000, \n				0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000, \n				0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000, \n				0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000, \n				0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };\n			static const uint32 exponent_table[64] = { \n				0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000, \n				0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000, \n				0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000, \n				0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };\n			static const unsigned short offset_table[64] = { \n				   0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, \n				   0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };\n			uint32 bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];\n//			uint32 bits = mantissa_table[(((value&0x7C00)!=0)<<10)+(value&0x3FF)] + exponent_table[value>>10];\n//			return *reinterpret_cast<float*>(&bits);			//violating strict aliasing!\n			float out;\n			std::memcpy(&out, &bits, sizeof(float));\n			return out;\n		}\n\n		/// Convert half-precision to non-IEEE single-precision.\n		/// \\param value binary representation of half-precision value\n		/// \\return single-precision value\n		inline float half2float_impl(uint16 value, false_type)\n		{\n			float out;\n			int abs = value & 0x7FFF;\n			if(abs > 0x7C00)\n				out = std::numeric_limits<float>::has_quiet_NaN ? std::numeric_limits<float>::quiet_NaN() : 0.0f;\n			else if(abs == 0x7C00)\n				out = std::numeric_limits<float>::has_infinity ? std::numeric_limits<float>::infinity() : std::numeric_limits<float>::max();\n			else if(abs > 0x3FF)\n				out = std::ldexp(static_cast<float>((value&0x3FF)|0x400), (abs>>10)-25);\n			else\n				out = std::ldexp(static_cast<float>(abs), -24);\n			return (value&0x8000) ? -out : out;\n		}\n\n		/// Convert half-precision to single-precision.\n		/// \\param value binary representation of half-precision value\n		/// \\return single-precision value\n		inline float half2float(uint16 value)\n		{\n			return half2float_impl(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());\n		}\n\n		/// Convert half-precision floating point to integer.\n		/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n		/// \\tparam E `true` for round to even, `false` for round away from zero\n		/// \\tparam T type to convert to (buitlin integer type with at least 16 bits precision, excluding any implicit sign bits)\n		/// \\param value binary representation of half-precision value\n		/// \\return integral value\n		template<std::float_round_style R,bool E,typename T> T half2int_impl(uint16 value)\n		{\n			unsigned int e = value & 0x7FFF;\n			if(e >= 0x7C00)\n				return (value&0x8000) ? std::numeric_limits<T>::min() : std::numeric_limits<T>::max();\n			if(e < 0x3800)\n			{\n				if(R == std::round_toward_infinity)\n					return T(~(value>>15)&(e!=0));\n				else if(R == std::round_toward_neg_infinity)\n					return -T(value>0x8000);\n				return T();\n			}\n			int17 m = (value&0x3FF) | 0x400;\n			e >>= 10;\n			if(e < 25)\n			{\n				if(R == std::round_indeterminate || R == std::round_toward_zero)\n					m >>= 25 - e;\n				else\n				{\n					if(R == std::round_to_nearest)\n						m += (1<<(24-e)) - (~(m>>(25-e))&E);\n					else if(R == std::round_toward_infinity)\n						m += ((value>>15)-1) & ((1<<(25-e))-1U);\n					else if(R == std::round_toward_neg_infinity)\n						m += -(value>>15) & ((1<<(25-e))-1U);\n					m >>= 25 - e;\n				}\n			}\n			else\n				m <<= e - 25;\n//			if(std::numeric_limits<T>::digits < 16)\n//				return std::min(std::max(m, static_cast<int17>(std::numeric_limits<T>::min())), static_cast<int17>(std::numeric_limits<T>::max()));\n			return static_cast<T>((value&0x8000) ? -m : m);\n		}\n\n		/// Convert half-precision floating point to integer.\n		/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n		/// \\tparam T type to convert to (buitlin integer type with at least 16 bits precision, excluding any implicit sign bits)\n		/// \\param value binary representation of half-precision value\n		/// \\return integral value\n		template<std::float_round_style R,typename T> T half2int(uint16 value) { return half2int_impl<R,HALF_ROUND_TIES_TO_EVEN,T>(value); }\n\n		/// Convert half-precision floating point to integer using round-to-nearest-away-from-zero.\n		/// \\tparam T type to convert to (buitlin integer type with at least 16 bits precision, excluding any implicit sign bits)\n		/// \\param value binary representation of half-precision value\n		/// \\return integral value\n		template<typename T> T half2int_up(uint16 value) { return half2int_impl<std::round_to_nearest,0,T>(value); }\n\n		/// Round half-precision number to nearest integer value.\n		/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n		/// \\tparam E `true` for round to even, `false` for round away from zero\n		/// \\param value binary representation of half-precision value\n		/// \\return half-precision bits for nearest integral value\n		template<std::float_round_style R,bool E> uint16 round_half_impl(uint16 value)\n		{\n			unsigned int e = value & 0x7FFF;\n			uint16 result = value;\n			if(e < 0x3C00)\n			{\n				result &= 0x8000;\n				if(R == std::round_to_nearest)\n					result |= 0x3C00U & -(e>=(0x3800+E));\n				else if(R == std::round_toward_infinity)\n					result |= 0x3C00U & -(~(value>>15)&(e!=0));\n				else if(R == std::round_toward_neg_infinity)\n					result |= 0x3C00U & -(value>0x8000);\n			}\n			else if(e < 0x6400)\n			{\n				e = 25 - (e>>10);\n				unsigned int mask = (1<<e) - 1;\n				if(R == std::round_to_nearest)\n					result += (1<<(e-1)) - (~(result>>e)&E);\n				else if(R == std::round_toward_infinity)\n					result += mask & ((value>>15)-1);\n				else if(R == std::round_toward_neg_infinity)\n					result += mask & -(value>>15);\n				result &= ~mask;\n			}\n			return result;\n		}\n\n		/// Round half-precision number to nearest integer value.\n		/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n		/// \\param value binary representation of half-precision value\n		/// \\return half-precision bits for nearest integral value\n		template<std::float_round_style R> uint16 round_half(uint16 value) { return round_half_impl<R,HALF_ROUND_TIES_TO_EVEN>(value); }\n\n		/// Round half-precision number to nearest integer value using round-to-nearest-away-from-zero.\n		/// \\param value binary representation of half-precision value\n		/// \\return half-precision bits for nearest integral value\n		inline uint16 round_half_up(uint16 value) { return round_half_impl<std::round_to_nearest,0>(value); }\n		/// \\}\n\n		struct functions;\n		template<typename> struct unary_specialized;\n		template<typename,typename> struct binary_specialized;\n		template<typename,typename,std::float_round_style> struct half_caster;\n	}\n\n	/// Half-precision floating point type.\n	/// This class implements an IEEE-conformant half-precision floating point type with the usual arithmetic operators and \n	/// conversions. It is implicitly convertible to single-precision floating point, which makes artihmetic expressions and \n	/// functions with mixed-type operands to be of the most precise operand type. Additionally all arithmetic operations \n	/// (and many mathematical functions) are carried out in single-precision internally. All conversions from single- to \n	/// half-precision are done using truncation (round towards zero), but temporary results inside chained arithmetic \n	/// expressions are kept in single-precision as long as possible (while of course still maintaining a strong half-precision type).\n	///\n	/// According to the C++98/03 definition, the half type is not a POD type. But according to C++11's less strict and \n	/// extended definitions it is both a standard layout type and a trivially copyable type (even if not a POD type), which \n	/// means it can be standard-conformantly copied using raw binary copies. But in this context some more words about the \n	/// actual size of the type. Although the half is representing an IEEE 16-bit type, it does not neccessarily have to be of \n	/// exactly 16-bits size. But on any reasonable implementation the actual binary representation of this type will most \n	/// probably not ivolve any additional \"magic\" or padding beyond the simple binary representation of the underlying 16-bit \n	/// IEEE number, even if not strictly guaranteed by the standard. But even then it only has an actual size of 16 bits if \n	/// your C++ implementation supports an unsigned integer type of exactly 16 bits width. But this should be the case on \n	/// nearly any reasonable platform.\n	///\n	/// So if your C++ implementation is not totally exotic or imposes special alignment requirements, it is a reasonable \n	/// assumption that the data of a half is just comprised of the 2 bytes of the underlying IEEE representation.\n	class half\n	{\n		friend struct detail::functions;\n		friend struct detail::unary_specialized<half>;\n		friend struct detail::binary_specialized<half,half>;\n		template<typename,typename,std::float_round_style> friend struct detail::half_caster;\n		friend class std::numeric_limits<half>;\n	#if HALF_ENABLE_CPP11_HASH\n		friend struct std::hash<half>;\n	#endif\n\n	public:\n		/// Default constructor.\n		/// This initializes the half to 0. Although this does not match the builtin types' default-initialization semantics \n		/// and may be less efficient than no initialization, it is needed to provide proper value-initialization semantics.\n		HALF_CONSTEXPR half() : data_() {}\n\n		/// Copy constructor.\n		/// \\tparam T type of concrete half expression\n		/// \\param rhs half expression to copy from\n		half(detail::expr rhs) : data_(detail::float2half<round_style>(rhs)) {}\n\n		/// Conversion constructor.\n		/// \\param rhs float to convert\n		explicit half(float rhs) : data_(detail::float2half<round_style>(rhs)) {}\n	\n		/// Conversion to single-precision.\n		/// \\return single precision value representing expression value\n		operator float() const { return detail::half2float(data_); }\n\n		/// Assignment operator.\n		/// \\tparam T type of concrete half expression\n		/// \\param rhs half expression to copy from\n		/// \\return reference to this half\n		half& operator=(detail::expr rhs) { return *this = static_cast<float>(rhs); }\n\n		/// Arithmetic assignment.\n		/// \\tparam T type of concrete half expression\n		/// \\param rhs half expression to add\n		/// \\return reference to this half\n		template<typename T> typename detail::enable<half&,T>::type operator+=(T rhs) { return *this += static_cast<float>(rhs); }\n\n		/// Arithmetic assignment.\n		/// \\tparam T type of concrete half expression\n		/// \\param rhs half expression to subtract\n		/// \\return reference to this half\n		template<typename T> typename detail::enable<half&,T>::type operator-=(T rhs) { return *this -= static_cast<float>(rhs); }\n\n		/// Arithmetic assignment.\n		/// \\tparam T type of concrete half expression\n		/// \\param rhs half expression to multiply with\n		/// \\return reference to this half\n		template<typename T> typename detail::enable<half&,T>::type operator*=(T rhs) { return *this *= static_cast<float>(rhs); }\n\n		/// Arithmetic assignment.\n		/// \\tparam T type of concrete half expression\n		/// \\param rhs half expression to divide by\n		/// \\return reference to this half\n		template<typename T> typename detail::enable<half&,T>::type operator/=(T rhs) { return *this /= static_cast<float>(rhs); }\n\n		/// Assignment operator.\n		/// \\param rhs single-precision value to copy from\n		/// \\return reference to this half\n		half& operator=(float rhs) { data_ = detail::float2half<round_style>(rhs); return *this; }\n\n		/// Arithmetic assignment.\n		/// \\param rhs single-precision value to add\n		/// \\return reference to this half\n		half& operator+=(float rhs) { data_ = detail::float2half<round_style>(detail::half2float(data_)+rhs); return *this; }\n\n		/// Arithmetic assignment.\n		/// \\param rhs single-precision value to subtract\n		/// \\return reference to this half\n		half& operator-=(float rhs) { data_ = detail::float2half<round_style>(detail::half2float(data_)-rhs); return *this; }\n\n		/// Arithmetic assignment.\n		/// \\param rhs single-precision value to multiply with\n		/// \\return reference to this half\n		half& operator*=(float rhs) { data_ = detail::float2half<round_style>(detail::half2float(data_)*rhs); return *this; }\n\n		/// Arithmetic assignment.\n		/// \\param rhs single-precision value to divide by\n		/// \\return reference to this half\n		half& operator/=(float rhs) { data_ = detail::float2half<round_style>(detail::half2float(data_)/rhs); return *this; }\n\n		/// Prefix increment.\n		/// \\return incremented half value\n		half& operator++() { return *this += 1.0f; }\n\n		/// Prefix decrement.\n		/// \\return decremented half value\n		half& operator--() { return *this -= 1.0f; }\n\n		/// Postfix increment.\n		/// \\return non-incremented half value\n		half operator++(int) { half out(*this); ++*this; return out; }\n\n		/// Postfix decrement.\n		/// \\return non-decremented half value\n		half operator--(int) { half out(*this); --*this; return out; }\n	\n	private:\n		/// Rounding mode to use (always `std::round_indeterminate`)\n		static const std::float_round_style round_style = (std::float_round_style)(HALF_ROUND_STYLE);\n\n		/// Constructor.\n		/// \\param bits binary representation to set half to\n		HALF_CONSTEXPR half(detail::binary_t, detail::uint16 bits) : data_(bits) {}\n\n		/// Internal binary representation\n		detail::uint16 data_;\n	};\n\n#if HALF_ENABLE_CPP11_USER_LITERALS\n	/// Library-defined half-precision literals.\n	/// Import this namespace to enable half-precision floating point literals:\n	/// ~~~~{.cpp}\n	/// using namespace half_float::literal;\n	/// half_float::half = 4.2_h;\n	/// ~~~~\n	namespace literal\n	{\n		/// Half literal.\n		/// While this returns an actual half-precision value, half literals can unfortunately not be constant expressions due \n		/// to rather involved single-to-half conversion.\n		/// \\param value literal value\n		/// \\return half with given value (if representable)\n		inline half operator \"\" _h(long double value) { return half(static_cast<float>(value)); }\n	}\n#endif\n\n	namespace detail\n	{\n		/// Wrapper implementing unspecialized half-precision functions.\n		struct functions\n		{\n			/// Addition implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\return Half-precision sum stored in single-precision\n			static expr plus(float x, float y) { return expr(x+y); }\n\n			/// Subtraction implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\return Half-precision difference stored in single-precision\n			static expr minus(float x, float y) { return expr(x-y); }\n\n			/// Multiplication implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\return Half-precision product stored in single-precision\n			static expr multiplies(float x, float y) { return expr(x*y); }\n\n			/// Division implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\return Half-precision quotient stored in single-precision\n			static expr divides(float x, float y) { return expr(x/y); }\n\n			/// Output implementation.\n			/// \\param out stream to write to\n			/// \\param arg value to write\n			/// \\return reference to stream\n			template<typename charT,typename traits> static std::basic_ostream<charT,traits>& write(std::basic_ostream<charT,traits> &out, float arg) { return out << arg; }\n\n			/// Input implementation.\n			/// \\param in stream to read from\n			/// \\param arg half to read into\n			/// \\return reference to stream\n			template<typename charT,typename traits> static std::basic_istream<charT,traits>& read(std::basic_istream<charT,traits> &in, half &arg)\n			{\n				float f;\n				if(in >> f)\n					arg = f;\n				return in;\n			}\n\n			/// Modulo implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\return Half-precision division remainder stored in single-precision\n			static expr fmod(float x, float y) { return expr(std::fmod(x, y)); }\n\n			/// Remainder implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\return Half-precision division remainder stored in single-precision\n			static expr remainder(float x, float y)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::remainder(x, y));\n			#else\n				if(builtin_isnan(x) || builtin_isnan(y))\n					return expr(std::numeric_limits<float>::quiet_NaN());\n				float ax = std::fabs(x), ay = std::fabs(y);\n				if(ax >= 65536.0f || ay < std::ldexp(1.0f, -24))\n					return expr(std::numeric_limits<float>::quiet_NaN());\n				if(ay >= 65536.0f)\n					return expr(x);\n				if(ax == ay)\n					return expr(builtin_signbit(x) ? -0.0f : 0.0f);\n				ax = std::fmod(ax, ay+ay);\n				float y2 = 0.5f * ay;\n				if(ax > y2)\n				{\n					ax -= ay;\n					if(ax >= y2)\n						ax -= ay;\n				}\n				return expr(builtin_signbit(x) ? -ax : ax);\n			#endif\n			}\n\n			/// Remainder implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\param quo address to store quotient bits at\n			/// \\return Half-precision division remainder stored in single-precision\n			static expr remquo(float x, float y, int *quo)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::remquo(x, y, quo));\n			#else\n				if(builtin_isnan(x) || builtin_isnan(y))\n					return expr(std::numeric_limits<float>::quiet_NaN());\n				bool sign = builtin_signbit(x), qsign = static_cast<bool>(sign^builtin_signbit(y));\n				float ax = std::fabs(x), ay = std::fabs(y);\n				if(ax >= 65536.0f || ay < std::ldexp(1.0f, -24))\n					return expr(std::numeric_limits<float>::quiet_NaN());\n				if(ay >= 65536.0f)\n					return expr(x);\n				if(ax == ay)\n					return *quo = qsign ? -1 : 1, expr(sign ? -0.0f : 0.0f);\n				ax = std::fmod(ax, 8.0f*ay);\n				int cquo = 0;\n				if(ax >= 4.0f * ay)\n				{\n					ax -= 4.0f * ay;\n					cquo += 4;\n				}\n				if(ax >= 2.0f * ay)\n				{\n					ax -= 2.0f * ay;\n					cquo += 2;\n				}\n				float y2 = 0.5f * ay;\n				if(ax > y2)\n				{\n					ax -= ay;\n					++cquo;\n					if(ax >= y2)\n					{\n						ax -= ay;\n						++cquo;\n					}\n				}\n				return *quo = qsign ? -cquo : cquo, expr(sign ? -ax : ax);\n			#endif\n			}\n\n			/// Positive difference implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\return Positive difference stored in single-precision\n			static expr fdim(float x, float y)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::fdim(x, y));\n			#else\n				return expr((x<=y) ? 0.0f : (x-y));\n			#endif\n			}\n\n			/// Fused multiply-add implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\param z third operand\n			/// \\return \\a x * \\a y + \\a z stored in single-precision\n			static expr fma(float x, float y, float z)\n			{\n			#if HALF_ENABLE_CPP11_CMATH && defined(FP_FAST_FMAF)\n				return expr(std::fma(x, y, z));\n			#else\n				return expr(x*y+z);\n			#endif\n			}\n\n			/// Get NaN.\n			/// \\return Half-precision quiet NaN\n			static half nanh(const char*) { return half(binary, 0x7FFF); }\n\n			/// Exponential implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr exp(float arg) { return expr(std::exp(arg)); }\n\n			/// Exponential implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr expm1(float arg)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::expm1(arg));\n			#else\n				return expr(static_cast<float>(std::exp(static_cast<double>(arg))-1.0));\n			#endif\n			}\n\n			/// Binary exponential implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr exp2(float arg)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::exp2(arg));\n			#else\n				return expr(static_cast<float>(std::exp(arg*0.69314718055994530941723212145818)));\n			#endif\n			}\n\n			/// Logarithm implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr log(float arg) { return expr(std::log(arg)); }\n\n			/// Common logarithm implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr log10(float arg) { return expr(std::log10(arg)); }\n\n			/// Logarithm implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr log1p(float arg)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::log1p(arg));\n			#else\n				return expr(static_cast<float>(std::log(1.0+arg)));\n			#endif\n			}\n\n			/// Binary logarithm implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr log2(float arg)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::log2(arg));\n			#else\n				return expr(static_cast<float>(std::log(static_cast<double>(arg))*1.4426950408889634073599246810019));\n			#endif\n			}\n\n			/// Square root implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr sqrt(float arg) { return expr(std::sqrt(arg)); }\n\n			/// Cubic root implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr cbrt(float arg)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::cbrt(arg));\n			#else\n				if(builtin_isnan(arg) || builtin_isinf(arg))\n					return expr(arg);\n				return expr(builtin_signbit(arg) ? -static_cast<float>(std::pow(std::fabs(static_cast<double>(arg)), 1.0/3.0)) : \n					static_cast<float>(std::pow(static_cast<double>(arg), 1.0/3.0)));\n			#endif\n			}\n\n			/// Hypotenuse implementation.\n			/// \\param x first argument\n			/// \\param y second argument\n			/// \\return function value stored in single-preicision\n			static expr hypot(float x, float y)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::hypot(x, y));\n			#else\n				return expr((builtin_isinf(x) || builtin_isinf(y)) ? std::numeric_limits<float>::infinity() : \n					static_cast<float>(std::sqrt(static_cast<double>(x)*x+static_cast<double>(y)*y)));\n			#endif\n			}\n\n			/// Power implementation.\n			/// \\param base value to exponentiate\n			/// \\param exp power to expontiate to\n			/// \\return function value stored in single-preicision\n			static expr pow(float base, float exp) { return expr(std::pow(base, exp)); }\n\n			/// Sine implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr sin(float arg) { return expr(std::sin(arg)); }\n\n			/// Cosine implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr cos(float arg) { return expr(std::cos(arg)); }\n\n			/// Tan implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr tan(float arg) { return expr(std::tan(arg)); }\n\n			/// Arc sine implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr asin(float arg) { return expr(std::asin(arg)); }\n\n			/// Arc cosine implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr acos(float arg) { return expr(std::acos(arg)); }\n\n			/// Arc tangent implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr atan(float arg) { return expr(std::atan(arg)); }\n\n			/// Arc tangent implementation.\n			/// \\param x first argument\n			/// \\param y second argument\n			/// \\return function value stored in single-preicision\n			static expr atan2(float x, float y) { return expr(std::atan2(x, y)); }\n\n			/// Hyperbolic sine implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr sinh(float arg) { return expr(std::sinh(arg)); }\n\n			/// Hyperbolic cosine implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr cosh(float arg) { return expr(std::cosh(arg)); }\n\n			/// Hyperbolic tangent implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr tanh(float arg) { return expr(std::tanh(arg)); }\n\n			/// Hyperbolic area sine implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr asinh(float arg)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::asinh(arg));\n			#else\n				return expr((arg==-std::numeric_limits<float>::infinity()) ? arg : static_cast<float>(std::log(arg+std::sqrt(arg*arg+1.0))));\n			#endif\n			}\n\n			/// Hyperbolic area cosine implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr acosh(float arg)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::acosh(arg));\n			#else\n				return expr((arg<-1.0f) ? std::numeric_limits<float>::quiet_NaN() : static_cast<float>(std::log(arg+std::sqrt(arg*arg-1.0))));\n			#endif\n			}\n\n			/// Hyperbolic area tangent implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr atanh(float arg)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::atanh(arg));\n			#else\n				return expr(static_cast<float>(0.5*std::log((1.0+arg)/(1.0-arg))));\n			#endif\n			}\n\n			/// Error function implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr erf(float arg)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::erf(arg));\n			#else\n				return expr(static_cast<float>(erf(static_cast<double>(arg))));\n			#endif\n			}\n\n			/// Complementary implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr erfc(float arg)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::erfc(arg));\n			#else\n				return expr(static_cast<float>(1.0-erf(static_cast<double>(arg))));\n			#endif\n			}\n\n			/// Gamma logarithm implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr lgamma(float arg)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::lgamma(arg));\n			#else\n				if(builtin_isinf(arg))\n					return expr(std::numeric_limits<float>::infinity());\n				double z = static_cast<double>(arg);\n				if(z < 0)\n				{\n					double i, f = std::modf(-z, &i);\n					if(f == 0.0)\n						return expr(std::numeric_limits<float>::infinity());\n					return expr(static_cast<float>(1.1447298858494001741434273513531-std::log(std::abs(std::sin(3.1415926535897932384626433832795*f)))-lgamma(1.0-z)));\n				}\n//				if(z < 8.0)\n					return expr(static_cast<float>(lgamma(static_cast<double>(arg))));\n				return expr(static_cast<float>(0.5*(1.8378770664093454835606594728112-std::log(z))+z*(std::log(z+1.0/(12.0*z-1.0/(10.0*z)-1.0))-1.0)));\n			#endif\n			}\n\n			/// Gamma implementation.\n			/// \\param arg function argument\n			/// \\return function value stored in single-preicision\n			static expr tgamma(float arg)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::tgamma(arg));\n			#else\n				double z = static_cast<double>(arg);\n				if(z == 0.0)\n					return builtin_signbit(z) ? expr(-std::numeric_limits<float>::infinity()) : expr(std::numeric_limits<float>::infinity());\n				if(z < 0.0)\n				{\n					double i, f = std::modf(-z, &i);\n					if(f == 0.0)\n						return expr(std::numeric_limits<float>::quiet_NaN());\n					double sign = (std::fmod(i, 2.0)==0.0) ? -1.0 : 1.0;\n					return expr(static_cast<float>(sign*3.1415926535897932384626433832795/(std::sin(3.1415926535897932384626433832795*f)*std::exp(lgamma(1.0-z)))));\n				}\n				if(builtin_isinf(arg))\n					return expr(arg);\n//				if(arg < 8.0f)\n					return expr(static_cast<float>(std::exp(lgamma(z))));\n				return expr(static_cast<float>(std::sqrt(6.283185307179586476925286766559/z)*std::pow(0.36787944117144232159552377016146*(z+1.0/(12.0*z-1.0/(10.0*z))), z)));\n			#endif\n			}\n\n			/// Floor implementation.\n			/// \\param arg value to round\n			/// \\return rounded value\n			static half floor(half arg) { return half(binary, round_half<std::round_toward_neg_infinity>(arg.data_)); }\n\n			/// Ceiling implementation.\n			/// \\param arg value to round\n			/// \\return rounded value\n			static half ceil(half arg) { return half(binary, round_half<std::round_toward_infinity>(arg.data_)); }\n\n			/// Truncation implementation.\n			/// \\param arg value to round\n			/// \\return rounded value\n			static half trunc(half arg) { return half(binary, round_half<std::round_toward_zero>(arg.data_)); }\n\n			/// Nearest integer implementation.\n			/// \\param arg value to round\n			/// \\return rounded value\n			static half round(half arg) { return half(binary, round_half_up(arg.data_)); }\n\n			/// Nearest integer implementation.\n			/// \\param arg value to round\n			/// \\return rounded value\n			static long lround(half arg) { return detail::half2int_up<long>(arg.data_); }\n\n			/// Nearest integer implementation.\n			/// \\param arg value to round\n			/// \\return rounded value\n			static half rint(half arg) { return half(binary, round_half<half::round_style>(arg.data_)); }\n\n			/// Nearest integer implementation.\n			/// \\param arg value to round\n			/// \\return rounded value\n			static long lrint(half arg) { return detail::half2int<half::round_style,long>(arg.data_); }\n\n		#if HALF_ENABLE_CPP11_LONG_LONG\n			/// Nearest integer implementation.\n			/// \\param arg value to round\n			/// \\return rounded value\n			static long long llround(half arg) { return detail::half2int_up<long long>(arg.data_); }\n\n			/// Nearest integer implementation.\n			/// \\param arg value to round\n			/// \\return rounded value\n			static long long llrint(half arg) { return detail::half2int<half::round_style,long long>(arg.data_); }\n		#endif\n\n			/// Decompression implementation.\n			/// \\param arg number to decompress\n			/// \\param exp address to store exponent at\n			/// \\return normalized significant\n			static half frexp(half arg, int *exp)\n			{\n				unsigned int m = arg.data_ & 0x7FFF;\n				if(m >= 0x7C00 || !m)\n					return *exp = 0, arg;\n				int e = m >> 10;\n				if(!e)\n					for(m<<=1; m<0x400; m<<=1,--e) ;\n				return *exp = e-14, half(binary, static_cast<uint16>((arg.data_&0x8000)|0x3800|(m&0x3FF)));\n			}\n\n			/// Decompression implementation.\n			/// \\param arg number to decompress\n			/// \\param iptr address to store integer part at\n			/// \\return fractional part\n			static half modf(half arg, half *iptr)\n			{\n				unsigned int e = arg.data_ & 0x7C00;\n				if(e > 0x6000)\n					return *iptr = arg, (e==0x7C00&&(arg.data_&0x3FF)) ? arg : half(binary, arg.data_&0x8000);\n				if(e < 0x3C00)\n					return iptr->data_ = arg.data_ & 0x8000, arg;\n				e >>= 10;\n				unsigned int mask = (1<<(25-e)) - 1, m = arg.data_ & mask;\n				iptr->data_ = arg.data_ & ~mask;\n				if(!m)\n					return half(binary, arg.data_&0x8000);\n				for(; m<0x400; m<<=1,--e) ;\n				return half(binary, static_cast<uint16>((arg.data_&0x8000)|(e<<10)|(m&0x3FF)));\n			}\n\n			/// Scaling implementation.\n			/// \\param arg number to scale\n			/// \\param exp power of two to scale by\n			/// \\return scaled number\n			static half scalbln(half arg, long exp)\n			{\n				long e = arg.data_ & 0x7C00;\n				if(e == 0x7C00)\n					return arg;\n				unsigned int m = arg.data_ & 0x3FF;\n				if(e >>= 10)\n					m |= 0x400;\n				else\n				{\n					if(!m)\n						return arg;\n					for(m<<=1; m<0x400; m<<=1,--e) ;\n				}\n				e += exp;\n				uint16 value = arg.data_ & 0x8000;\n				if(e > 30)\n				{\n					if(half::round_style == std::round_toward_zero)\n						value |= 0x7BFF;\n					else if(half::round_style == std::round_toward_infinity)\n						value |= 0x7C00 - (value>>15);\n					else if(half::round_style == std::round_toward_neg_infinity)\n						value |= 0x7BFF + (value>>15);\n					else\n						value |= 0x7C00;\n				}\n				else if(e > 0)\n					value |= (e<<10) | (m&0x3FF);\n				else if(e > -11)\n				{\n					if(half::round_style == std::round_to_nearest)\n					{\n						m += 1 << -e;\n					#if HALF_ROUND_TIES_TO_EVEN\n						m -= (m>>(1-e)) & 1;\n					#endif\n					}\n					else if(half::round_style == std::round_toward_infinity)\n						m += ((value>>15)-1) & ((1<<(1-e))-1U);\n					else if(half::round_style == std::round_toward_neg_infinity)\n						m += -(value>>15) & ((1<<(1-e))-1U);\n					value |= m >> (1-e);\n				}\n				else if(half::round_style == std::round_toward_infinity)\n					value |= ((value>>15)-1) & 1;\n				else if(half::round_style == std::round_toward_neg_infinity)\n					value |= value >> 15;\n				return half(binary, value);\n			}\n\n			/// Exponent implementation.\n			/// \\param arg number to query\n			/// \\return floating point exponent\n			static int ilogb(half arg)\n			{\n				int exp = arg.data_ & 0x7FFF;\n				if(!exp)\n					return FP_ILOGB0;\n				if(exp < 0x7C00)\n				{\n					if(!(exp>>=10))\n						for(unsigned int m=(arg.data_&0x3FF); m<0x200; m<<=1,--exp) ;\n					return exp - 15;\n				}\n				if(exp > 0x7C00)\n					return FP_ILOGBNAN;\n				return INT_MAX;\n			}\n\n			/// Exponent implementation.\n			/// \\param arg number to query\n			/// \\return floating point exponent\n			static half logb(half arg)\n			{\n				int exp = arg.data_ & 0x7FFF;\n				if(!exp)\n					return half(binary, 0xFC00);\n				if(exp < 0x7C00)\n				{\n					if(!(exp>>=10))\n						for(unsigned int m=(arg.data_&0x3FF); m<0x200; m<<=1,--exp) ;\n					return half(static_cast<float>(exp-15));\n				}\n				if(exp > 0x7C00)\n					return arg;\n				return half(binary, 0x7C00);\n			}\n\n			/// Enumeration implementation.\n			/// \\param from number to increase/decrease\n			/// \\param to direction to enumerate into\n			/// \\return next representable number\n			static half nextafter(half from, half to)\n			{\n				uint16 fabs = from.data_ & 0x7FFF, tabs = to.data_ & 0x7FFF;\n				if(fabs > 0x7C00)\n					return from;\n				if(tabs > 0x7C00 || from.data_ == to.data_ || !(fabs|tabs))\n					return to;\n				if(!fabs)\n					return half(binary, (to.data_&0x8000)+1);\n				bool lt = (signbit(from) ? (static_cast<int17>(0x8000)-from.data_) : static_cast<int17>(from.data_)) < \n					(signbit(to) ? (static_cast<int17>(0x8000)-to.data_) : static_cast<int17>(to.data_));\n				return half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lt))<<1)-1);\n			}\n\n			/// Enumeration implementation.\n			/// \\param from number to increase/decrease\n			/// \\param to direction to enumerate into\n			/// \\return next representable number\n			static half nexttoward(half from, long double to)\n			{\n				if(isnan(from))\n					return from;\n				long double lfrom = static_cast<long double>(from);\n				if(builtin_isnan(to) || lfrom == to)\n					return half(static_cast<float>(to));\n				if(!(from.data_&0x7FFF))\n					return half(binary, (static_cast<detail::uint16>(builtin_signbit(to))<<15)+1);\n				return half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lfrom<to))<<1)-1);\n			}\n\n			/// Sign implementation\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\return composed value\n			static half copysign(half x, half y) { return half(binary, x.data_^((x.data_^y.data_)&0x8000)); }\n\n			/// Classification implementation.\n			/// \\param arg value to classify\n			/// \\retval true if infinite number\n			/// \\retval false else\n			static int fpclassify(half arg)\n			{\n				unsigned int abs = arg.data_ & 0x7FFF;\n				if(abs > 0x7C00)\n					return FP_NAN;\n				if(abs == 0x7C00)\n					return FP_INFINITE;\n				if(abs > 0x3FF)\n					return FP_NORMAL;\n				return abs ? FP_SUBNORMAL : FP_ZERO;\n			}\n\n			/// Classification implementation.\n			/// \\param arg value to classify\n			/// \\retval true if finite number\n			/// \\retval false else\n			static bool isfinite(half arg) { return (arg.data_&0x7C00) != 0x7C00; }\n\n			/// Classification implementation.\n			/// \\param arg value to classify\n			/// \\retval true if infinite number\n			/// \\retval false else\n			static bool isinf(half arg) { return (arg.data_&0x7FFF) == 0x7C00; }\n\n			/// Classification implementation.\n			/// \\param arg value to classify\n			/// \\retval true if not a number\n			/// \\retval false else\n			static bool isnan(half arg) { return (arg.data_&0x7FFF) > 0x7C00; }\n\n			/// Classification implementation.\n			/// \\param arg value to classify\n			/// \\retval true if normal number\n			/// \\retval false else\n			static bool isnormal(half arg) { return ((arg.data_&0x7C00)!=0) & ((arg.data_&0x7C00)!=0x7C00); }\n\n			/// Sign bit implementation.\n			/// \\param arg value to check\n			/// \\retval true if signed\n			/// \\retval false if unsigned\n			static bool signbit(half arg) { return (arg.data_&0x8000) != 0; }\n\n			/// Comparison implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\retval true if operands equal\n			/// \\retval false else\n			static bool isequal(half x, half y) { return (x.data_==y.data_ || !((x.data_|y.data_)&0x7FFF)) && !isnan(x); }\n\n			/// Comparison implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\retval true if operands not equal\n			/// \\retval false else\n			static bool isnotequal(half x, half y) { return (x.data_!=y.data_ && ((x.data_|y.data_)&0x7FFF)) || isnan(x); }\n\n			/// Comparison implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\retval true if \\a x > \\a y\n			/// \\retval false else\n			static bool isgreater(half x, half y) { return !isnan(x) && !isnan(y) && ((signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : \n				static_cast<int17>(x.data_)) > (signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))); }\n\n			/// Comparison implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\retval true if \\a x >= \\a y\n			/// \\retval false else\n			static bool isgreaterequal(half x, half y) { return !isnan(x) && !isnan(y) && ((signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : \n				static_cast<int17>(x.data_)) >= (signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))); }\n\n			/// Comparison implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\retval true if \\a x < \\a y\n			/// \\retval false else\n			static bool isless(half x, half y) { return !isnan(x) && !isnan(y) && ((signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : \n				static_cast<int17>(x.data_)) < (signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))); }\n\n			/// Comparison implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\retval true if \\a x <= \\a y\n			/// \\retval false else\n			static bool islessequal(half x, half y) { return !isnan(x) && !isnan(y) && ((signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : \n				static_cast<int17>(x.data_)) <= (signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))); }\n\n			/// Comparison implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\retval true neither \\a x > \\a y nor \\a x < \\a y\n			/// \\retval false else\n			static bool islessgreater(half x, half y)\n			{\n				if(isnan(x) || isnan(y))\n					return false;\n				int17 a = signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_);\n				int17 b = signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_);\n				return a < b || a > b;\n			}\n\n			/// Comparison implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\retval true if operand unordered\n			/// \\retval false else\n			static bool isunordered(half x, half y) { return isnan(x) || isnan(y); }\n\n		private:\n			static double erf(double arg)\n			{\n				if(builtin_isinf(arg))\n					return (arg<0.0) ? -1.0 : 1.0;\n				double x2 = static_cast<double>(arg) * static_cast<double>(arg), ax2 = 0.147 * x2;\n				double value = std::sqrt(1.0-std::exp(-x2*(1.2732395447351626861510701069801+ax2)/(1.0+ax2)));\n				return builtin_signbit(arg) ? -value : value;\n			}\n\n			static double lgamma(double arg)\n			{\n				double v = 1.0;\n				for(; arg<8.0; ++arg) v *= arg;\n				double w = 1.0 / (arg * arg);\n				return (((((((-0.02955065359477124183006535947712*w+0.00641025641025641025641025641026)*w+\n					-0.00191752691752691752691752691753)*w+8.4175084175084175084175084175084e-4)*w+\n					-5.952380952380952380952380952381e-4)*w+7.9365079365079365079365079365079e-4)*w+\n					-0.00277777777777777777777777777778)*w+0.08333333333333333333333333333333)/arg + \n					0.91893853320467274178032973640562 - std::log(v) - arg + (arg-0.5) * std::log(arg);\n			}\n		};\n\n		/// Wrapper for unary half-precision functions needing specialization for individual argument types.\n		/// \\tparam T argument type\n		template<typename T> struct unary_specialized\n		{\n			/// Negation implementation.\n			/// \\param arg value to negate\n			/// \\return negated value\n			static HALF_CONSTEXPR half negate(half arg) { return half(binary, arg.data_^0x8000); }\n\n			/// Absolute value implementation.\n			/// \\param arg function argument\n			/// \\return absolute value\n			static half fabs(half arg) { return half(binary, arg.data_&0x7FFF); }\n		};\n		template<> struct unary_specialized<expr>\n		{\n			static HALF_CONSTEXPR expr negate(float arg) { return expr(-arg); }\n			static expr fabs(float arg) { return expr(std::fabs(arg)); }\n		};\n\n		/// Wrapper for binary half-precision functions needing specialization for individual argument types.\n		/// \\tparam T first argument type\n		/// \\tparam U first argument type\n		template<typename T,typename U> struct binary_specialized\n		{\n			/// Minimum implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\return minimum value\n			static expr fmin(float x, float y)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::fmin(x, y));\n			#else\n				if(builtin_isnan(x))\n					return expr(y);\n				if(builtin_isnan(y))\n					return expr(x);\n				return expr(std::min(x, y));\n			#endif\n			}\n\n			/// Maximum implementation.\n			/// \\param x first operand\n			/// \\param y second operand\n			/// \\return maximum value\n			static expr fmax(float x, float y)\n			{\n			#if HALF_ENABLE_CPP11_CMATH\n				return expr(std::fmax(x, y));\n			#else\n				if(builtin_isnan(x))\n					return expr(y);\n				if(builtin_isnan(y))\n					return expr(x);\n				return expr(std::max(x, y));\n			#endif\n			}\n		};\n		template<> struct binary_specialized<half,half>\n		{\n			static half fmin(half x, half y)\n			{\n				if(functions::isnan(x))\n					return y;\n				if(functions::isnan(y))\n					return x;\n				return ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) >\n						(functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;\n			}\n			static half fmax(half x, half y)\n			{\n				if(functions::isnan(x))\n					return y;\n				if(functions::isnan(y))\n					return x;\n				return ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) <\n						(functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;\n			}\n		};\n\n		/// Helper class for half casts.\n		/// This class template has to be specialized for all valid cast argument to define an appropriate static `cast` member \n		/// function and a corresponding `type` member denoting its return type.\n		/// \\tparam T destination type\n		/// \\tparam U source type\n		/// \\tparam R rounding mode to use\n		template<typename T,typename U,std::float_round_style R=(std::float_round_style)(HALF_ROUND_STYLE)> struct half_caster {};\n		template<typename U,std::float_round_style R> struct half_caster<half,U,R>\n		{\n		#if HALF_ENABLE_CPP11_STATIC_ASSERT && HALF_ENABLE_CPP11_TYPE_TRAITS\n			static_assert(std::is_arithmetic<U>::value, \"half_cast from non-arithmetic type unsupported\");\n		#endif\n\n			typedef half type;\n			static half cast(U arg) { return cast_impl(arg, is_float<U>()); };\n\n		private:\n			static half cast_impl(U arg, true_type) { return half(binary, float2half<R>(static_cast<float>(arg))); }\n			static half cast_impl(U arg, false_type) { return half(binary, int2half<R>(arg)); }\n		};\n		template<typename T,std::float_round_style R> struct half_caster<T,half,R>\n		{\n		#if HALF_ENABLE_CPP11_STATIC_ASSERT && HALF_ENABLE_CPP11_TYPE_TRAITS\n			static_assert(std::is_arithmetic<T>::value, \"half_cast to non-arithmetic type unsupported\");\n		#endif\n\n			typedef T type;\n			template<typename U> static T cast(U arg) { return cast_impl(arg, is_float<T>()); }\n\n		private:\n			static T cast_impl(float arg, true_type) { return static_cast<T>(arg); }\n			static T cast_impl(half arg, false_type) { return half2int<R,T>(arg.data_); }\n		};\n		template<typename T,std::float_round_style R> struct half_caster<T,expr,R> : public half_caster<T,half,R> {};\n		template<std::float_round_style R> struct half_caster<half,half,R>\n		{\n			typedef half type;\n			static half cast(half arg) { return arg; }\n		};\n		template<std::float_round_style R> struct half_caster<half,expr,R> : public half_caster<half,half,R> {};\n\n		/// \\name Comparison operators\n		/// \\{\n\n		/// Comparison for equality.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\retval true if operands equal\n		/// \\retval false else\n		template<typename T,typename U> typename enable<bool,T,U>::type operator==(T x, U y) { return functions::isequal(x, y); }\n\n		/// Comparison for inequality.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\retval true if operands not equal\n		/// \\retval false else\n		template<typename T,typename U> typename enable<bool,T,U>::type operator!=(T x, U y) { return functions::isnotequal(x, y); }\n\n		/// Comparison for less than.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\retval true if \\a x less than \\a y\n		/// \\retval false else\n		template<typename T,typename U> typename enable<bool,T,U>::type operator<(T x, U y) { return functions::isless(x, y); }\n\n		/// Comparison for greater than.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\retval true if \\a x greater than \\a y\n		/// \\retval false else\n		template<typename T,typename U> typename enable<bool,T,U>::type operator>(T x, U y) { return functions::isgreater(x, y); }\n\n		/// Comparison for less equal.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\retval true if \\a x less equal \\a y\n		/// \\retval false else\n		template<typename T,typename U> typename enable<bool,T,U>::type operator<=(T x, U y) { return functions::islessequal(x, y); }\n\n		/// Comparison for greater equal.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\retval true if \\a x greater equal \\a y\n		/// \\retval false else\n		template<typename T,typename U> typename enable<bool,T,U>::type operator>=(T x, U y) { return functions::isgreaterequal(x, y); }\n\n		/// \\}\n		/// \\name Arithmetic operators\n		/// \\{\n\n		/// Add halfs.\n		/// \\param x left operand\n		/// \\param y right operand\n		/// \\return sum of half expressions\n		template<typename T,typename U> typename enable<expr,T,U>::type operator+(T x, U y) { return functions::plus(x, y); }\n\n		/// Subtract halfs.\n		/// \\param x left operand\n		/// \\param y right operand\n		/// \\return difference of half expressions\n		template<typename T,typename U> typename enable<expr,T,U>::type operator-(T x, U y) { return functions::minus(x, y); }\n\n		/// Multiply halfs.\n		/// \\param x left operand\n		/// \\param y right operand\n		/// \\return product of half expressions\n		template<typename T,typename U> typename enable<expr,T,U>::type operator*(T x, U y) { return functions::multiplies(x, y); }\n\n		/// Divide halfs.\n		/// \\param x left operand\n		/// \\param y right operand\n		/// \\return quotient of half expressions\n		template<typename T,typename U> typename enable<expr,T,U>::type operator/(T x, U y) { return functions::divides(x, y); }\n\n		/// Identity.\n		/// \\param arg operand\n		/// \\return uncahnged operand\n		template<typename T> HALF_CONSTEXPR typename enable<T,T>::type operator+(T arg) { return arg; }\n\n		/// Negation.\n		/// \\param arg operand\n		/// \\return negated operand\n		template<typename T> HALF_CONSTEXPR typename enable<T,T>::type operator-(T arg) { return unary_specialized<T>::negate(arg); }\n\n		/// \\}\n		/// \\name Input and output\n		/// \\{\n\n		/// Output operator.\n		/// \\param out output stream to write into\n		/// \\param arg half expression to write\n		/// \\return reference to output stream\n		template<typename T,typename charT,typename traits> typename enable<std::basic_ostream<charT,traits>&,T>::type\n			operator<<(std::basic_ostream<charT,traits> &out, T arg) { return functions::write(out, arg); }\n\n		/// Input operator.\n		/// \\param in input stream to read from\n		/// \\param arg half to read into\n		/// \\return reference to input stream\n		template<typename charT,typename traits> std::basic_istream<charT,traits>&\n			operator>>(std::basic_istream<charT,traits> &in, half &arg) { return functions::read(in, arg); }\n\n		/// \\}\n		/// \\name Basic mathematical operations\n		/// \\{\n\n		/// Absolute value.\n		/// \\param arg operand\n		/// \\return absolute value of \\a arg\n//		template<typename T> typename enable<T,T>::type abs(T arg) { return unary_specialized<T>::fabs(arg); }\n		inline half abs(half arg) { return unary_specialized<half>::fabs(arg); }\n		inline expr abs(expr arg) { return unary_specialized<expr>::fabs(arg); }\n\n		/// Absolute value.\n		/// \\param arg operand\n		/// \\return absolute value of \\a arg\n//		template<typename T> typename enable<T,T>::type fabs(T arg) { return unary_specialized<T>::fabs(arg); }\n		inline half fabs(half arg) { return unary_specialized<half>::fabs(arg); }\n		inline expr fabs(expr arg) { return unary_specialized<expr>::fabs(arg); }\n\n		/// Remainder of division.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\return remainder of floating point division.\n//		template<typename T,typename U> typename enable<expr,T,U>::type fmod(T x, U y) { return functions::fmod(x, y); }\n		inline expr fmod(half x, half y) { return functions::fmod(x, y); }\n		inline expr fmod(half x, expr y) { return functions::fmod(x, y); }\n		inline expr fmod(expr x, half y) { return functions::fmod(x, y); }\n		inline expr fmod(expr x, expr y) { return functions::fmod(x, y); }\n\n		/// Remainder of division.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\return remainder of floating point division.\n//		template<typename T,typename U> typename enable<expr,T,U>::type remainder(T x, U y) { return functions::remainder(x, y); }\n		inline expr remainder(half x, half y) { return functions::remainder(x, y); }\n		inline expr remainder(half x, expr y) { return functions::remainder(x, y); }\n		inline expr remainder(expr x, half y) { return functions::remainder(x, y); }\n		inline expr remainder(expr x, expr y) { return functions::remainder(x, y); }\n\n		/// Remainder of division.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\param quo address to store some bits of quotient at\n		/// \\return remainder of floating point division.\n//		template<typename T,typename U> typename enable<expr,T,U>::type remquo(T x, U y, int *quo) { return functions::remquo(x, y, quo); }\n		inline expr remquo(half x, half y, int *quo) { return functions::remquo(x, y, quo); }\n		inline expr remquo(half x, expr y, int *quo) { return functions::remquo(x, y, quo); }\n		inline expr remquo(expr x, half y, int *quo) { return functions::remquo(x, y, quo); }\n		inline expr remquo(expr x, expr y, int *quo) { return functions::remquo(x, y, quo); }\n\n		/// Fused multiply add.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\param z third operand\n		/// \\return ( \\a x * \\a y ) + \\a z rounded as one operation.\n//		template<typename T,typename U,typename V> typename enable<expr,T,U,V>::type fma(T x, U y, V z) { return functions::fma(x, y, z); }\n		inline expr fma(half x, half y, half z) { return functions::fma(x, y, z); }\n		inline expr fma(half x, half y, expr z) { return functions::fma(x, y, z); }\n		inline expr fma(half x, expr y, half z) { return functions::fma(x, y, z); }\n		inline expr fma(half x, expr y, expr z) { return functions::fma(x, y, z); }\n		inline expr fma(expr x, half y, half z) { return functions::fma(x, y, z); }\n		inline expr fma(expr x, half y, expr z) { return functions::fma(x, y, z); }\n		inline expr fma(expr x, expr y, half z) { return functions::fma(x, y, z); }\n		inline expr fma(expr x, expr y, expr z) { return functions::fma(x, y, z); }\n\n		/// Maximum of half expressions.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\return maximum of operands\n//		template<typename T,typename U> typename result<T,U>::type fmax(T x, U y) { return binary_specialized<T,U>::fmax(x, y); }\n		inline half fmax(half x, half y) { return binary_specialized<half,half>::fmax(x, y); }\n		inline expr fmax(half x, expr y) { return binary_specialized<half,expr>::fmax(x, y); }\n		inline expr fmax(expr x, half y) { return binary_specialized<expr,half>::fmax(x, y); }\n		inline expr fmax(expr x, expr y) { return binary_specialized<expr,expr>::fmax(x, y); }\n\n		/// Minimum of half expressions.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\return minimum of operands\n//		template<typename T,typename U> typename result<T,U>::type fmin(T x, U y) { return binary_specialized<T,U>::fmin(x, y); }\n		inline half fmin(half x, half y) { return binary_specialized<half,half>::fmin(x, y); }\n		inline expr fmin(half x, expr y) { return binary_specialized<half,expr>::fmin(x, y); }\n		inline expr fmin(expr x, half y) { return binary_specialized<expr,half>::fmin(x, y); }\n		inline expr fmin(expr x, expr y) { return binary_specialized<expr,expr>::fmin(x, y); }\n\n		/// Positive difference.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\return \\a x - \\a y or 0 if difference negative\n//		template<typename T,typename U> typename enable<expr,T,U>::type fdim(T x, U y) { return functions::fdim(x, y); }\n		inline expr fdim(half x, half y) { return functions::fdim(x, y); }\n		inline expr fdim(half x, expr y) { return functions::fdim(x, y); }\n		inline expr fdim(expr x, half y) { return functions::fdim(x, y); }\n		inline expr fdim(expr x, expr y) { return functions::fdim(x, y); }\n\n		/// Get NaN value.\n		/// \\param arg descriptive string (ignored)\n		/// \\return quiet NaN\n		inline half nanh(const char *arg) { return functions::nanh(arg); }\n\n		/// \\}\n		/// \\name Exponential functions\n		/// \\{\n\n		/// Exponential function.\n		/// \\param arg function argument\n		/// \\return e raised to \\a arg\n//		template<typename T> typename enable<expr,T>::type exp(T arg) { return functions::exp(arg); }\n		inline expr exp(half arg) { return functions::exp(arg); }\n		inline expr exp(expr arg) { return functions::exp(arg); }\n\n		/// Exponential minus one.\n		/// \\param arg function argument\n		/// \\return e raised to \\a arg subtracted by 1\n//		template<typename T> typename enable<expr,T>::type expm1(T arg) { return functions::expm1(arg); }\n		inline expr expm1(half arg) { return functions::expm1(arg); }\n		inline expr expm1(expr arg) { return functions::expm1(arg); }\n\n		/// Binary exponential.\n		/// \\param arg function argument\n		/// \\return 2 raised to \\a arg\n//		template<typename T> typename enable<expr,T>::type exp2(T arg) { return functions::exp2(arg); }\n		inline expr exp2(half arg) { return functions::exp2(arg); }\n		inline expr exp2(expr arg) { return functions::exp2(arg); }\n\n		/// Natural logorithm.\n		/// \\param arg function argument\n		/// \\return logarithm of \\a arg to base e\n//		template<typename T> typename enable<expr,T>::type log(T arg) { return functions::log(arg); }\n		inline expr log(half arg) { return functions::log(arg); }\n		inline expr log(expr arg) { return functions::log(arg); }\n\n		/// Common logorithm.\n		/// \\param arg function argument\n		/// \\return logarithm of \\a arg to base 10\n//		template<typename T> typename enable<expr,T>::type log10(T arg) { return functions::log10(arg); }\n		inline expr log10(half arg) { return functions::log10(arg); }\n		inline expr log10(expr arg) { return functions::log10(arg); }\n\n		/// Natural logorithm.\n		/// \\param arg function argument\n		/// \\return logarithm of \\a arg plus 1 to base e\n//		template<typename T> typename enable<expr,T>::type log1p(T arg) { return functions::log1p(arg); }\n		inline expr log1p(half arg) { return functions::log1p(arg); }\n		inline expr log1p(expr arg) { return functions::log1p(arg); }\n\n		/// Binary logorithm.\n		/// \\param arg function argument\n		/// \\return logarithm of \\a arg to base 2\n//		template<typename T> typename enable<expr,T>::type log2(T arg) { return functions::log2(arg); }\n		inline expr log2(half arg) { return functions::log2(arg); }\n		inline expr log2(expr arg) { return functions::log2(arg); }\n\n		/// \\}\n		/// \\name Power functions\n		/// \\{\n\n		/// Square root.\n		/// \\param arg function argument\n		/// \\return square root of \\a arg\n//		template<typename T> typename enable<expr,T>::type sqrt(T arg) { return functions::sqrt(arg); }\n		inline expr sqrt(half arg) { return functions::sqrt(arg); }\n		inline expr sqrt(expr arg) { return functions::sqrt(arg); }\n\n		/// Cubic root.\n		/// \\param arg function argument\n		/// \\return cubic root of \\a arg\n//		template<typename T> typename enable<expr,T>::type cbrt(T arg) { return functions::cbrt(arg); }\n		inline expr cbrt(half arg) { return functions::cbrt(arg); }\n		inline expr cbrt(expr arg) { return functions::cbrt(arg); }\n\n		/// Hypotenuse function.\n		/// \\param x first argument\n		/// \\param y second argument\n		/// \\return square root of sum of squares without internal over- or underflows\n//		template<typename T,typename U> typename enable<expr,T,U>::type hypot(T x, U y) { return functions::hypot(x, y); }\n		inline expr hypot(half x, half y) { return functions::hypot(x, y); }\n		inline expr hypot(half x, expr y) { return functions::hypot(x, y); }\n		inline expr hypot(expr x, half y) { return functions::hypot(x, y); }\n		inline expr hypot(expr x, expr y) { return functions::hypot(x, y); }\n\n		/// Power function.\n		/// \\param base first argument\n		/// \\param exp second argument\n		/// \\return \\a base raised to \\a exp\n//		template<typename T,typename U> typename enable<expr,T,U>::type pow(T base, U exp) { return functions::pow(base, exp); }\n		inline expr pow(half base, half exp) { return functions::pow(base, exp); }\n		inline expr pow(half base, expr exp) { return functions::pow(base, exp); }\n		inline expr pow(expr base, half exp) { return functions::pow(base, exp); }\n		inline expr pow(expr base, expr exp) { return functions::pow(base, exp); }\n\n		/// \\}\n		/// \\name Trigonometric functions\n		/// \\{\n\n		/// Sine function.\n		/// \\param arg function argument\n		/// \\return sine value of \\a arg\n//		template<typename T> typename enable<expr,T>::type sin(T arg) { return functions::sin(arg); }\n		inline expr sin(half arg) { return functions::sin(arg); }\n		inline expr sin(expr arg) { return functions::sin(arg); }\n\n		/// Cosine function.\n		/// \\param arg function argument\n		/// \\return cosine value of \\a arg\n//		template<typename T> typename enable<expr,T>::type cos(T arg) { return functions::cos(arg); }\n		inline expr cos(half arg) { return functions::cos(arg); }\n		inline expr cos(expr arg) { return functions::cos(arg); }\n\n		/// Tangent function.\n		/// \\param arg function argument\n		/// \\return tangent value of \\a arg\n//		template<typename T> typename enable<expr,T>::type tan(T arg) { return functions::tan(arg); }\n		inline expr tan(half arg) { return functions::tan(arg); }\n		inline expr tan(expr arg) { return functions::tan(arg); }\n\n		/// Arc sine.\n		/// \\param arg function argument\n		/// \\return arc sine value of \\a arg\n//		template<typename T> typename enable<expr,T>::type asin(T arg) { return functions::asin(arg); }\n		inline expr asin(half arg) { return functions::asin(arg); }\n		inline expr asin(expr arg) { return functions::asin(arg); }\n\n		/// Arc cosine function.\n		/// \\param arg function argument\n		/// \\return arc cosine value of \\a arg\n//		template<typename T> typename enable<expr,T>::type acos(T arg) { return functions::acos(arg); }\n		inline expr acos(half arg) { return functions::acos(arg); }\n		inline expr acos(expr arg) { return functions::acos(arg); }\n\n		/// Arc tangent function.\n		/// \\param arg function argument\n		/// \\return arc tangent value of \\a arg\n//		template<typename T> typename enable<expr,T>::type atan(T arg) { return functions::atan(arg); }\n		inline expr atan(half arg) { return functions::atan(arg); }\n		inline expr atan(expr arg) { return functions::atan(arg); }\n\n		/// Arc tangent function.\n		/// \\param x first argument\n		/// \\param y second argument\n		/// \\return arc tangent value\n//		template<typename T,typename U> typename enable<expr,T,U>::type atan2(T x, U y) { return functions::atan2(x, y); }\n		inline expr atan2(half x, half y) { return functions::atan2(x, y); }\n		inline expr atan2(half x, expr y) { return functions::atan2(x, y); }\n		inline expr atan2(expr x, half y) { return functions::atan2(x, y); }\n		inline expr atan2(expr x, expr y) { return functions::atan2(x, y); }\n\n		/// \\}\n		/// \\name Hyperbolic functions\n		/// \\{\n\n		/// Hyperbolic sine.\n		/// \\param arg function argument\n		/// \\return hyperbolic sine value of \\a arg\n//		template<typename T> typename enable<expr,T>::type sinh(T arg) { return functions::sinh(arg); }\n		inline expr sinh(half arg) { return functions::sinh(arg); }\n		inline expr sinh(expr arg) { return functions::sinh(arg); }\n\n		/// Hyperbolic cosine.\n		/// \\param arg function argument\n		/// \\return hyperbolic cosine value of \\a arg\n//		template<typename T> typename enable<expr,T>::type cosh(T arg) { return functions::cosh(arg); }\n		inline expr cosh(half arg) { return functions::cosh(arg); }\n		inline expr cosh(expr arg) { return functions::cosh(arg); }\n\n		/// Hyperbolic tangent.\n		/// \\param arg function argument\n		/// \\return hyperbolic tangent value of \\a arg\n//		template<typename T> typename enable<expr,T>::type tanh(T arg) { return functions::tanh(arg); }\n		inline expr tanh(half arg) { return functions::tanh(arg); }\n		inline expr tanh(expr arg) { return functions::tanh(arg); }\n\n		/// Hyperbolic area sine.\n		/// \\param arg function argument\n		/// \\return area sine value of \\a arg\n//		template<typename T> typename enable<expr,T>::type asinh(T arg) { return functions::asinh(arg); }\n		inline expr asinh(half arg) { return functions::asinh(arg); }\n		inline expr asinh(expr arg) { return functions::asinh(arg); }\n\n		/// Hyperbolic area cosine.\n		/// \\param arg function argument\n		/// \\return area cosine value of \\a arg\n//		template<typename T> typename enable<expr,T>::type acosh(T arg) { return functions::acosh(arg); }\n		inline expr acosh(half arg) { return functions::acosh(arg); }\n		inline expr acosh(expr arg) { return functions::acosh(arg); }\n\n		/// Hyperbolic area tangent.\n		/// \\param arg function argument\n		/// \\return area tangent value of \\a arg\n//		template<typename T> typename enable<expr,T>::type atanh(T arg) { return functions::atanh(arg); }\n		inline expr atanh(half arg) { return functions::atanh(arg); }\n		inline expr atanh(expr arg) { return functions::atanh(arg); }\n\n		/// \\}\n		/// \\name Error and gamma functions\n		/// \\{\n\n		/// Error function.\n		/// \\param arg function argument\n		/// \\return error function value of \\a arg\n//		template<typename T> typename enable<expr,T>::type erf(T arg) { return functions::erf(arg); }\n		inline expr erf(half arg) { return functions::erf(arg); }\n		inline expr erf(expr arg) { return functions::erf(arg); }\n\n		/// Complementary error function.\n		/// \\param arg function argument\n		/// \\return 1 minus error function value of \\a arg\n//		template<typename T> typename enable<expr,T>::type erfc(T arg) { return functions::erfc(arg); }\n		inline expr erfc(half arg) { return functions::erfc(arg); }\n		inline expr erfc(expr arg) { return functions::erfc(arg); }\n\n		/// Natural logarithm of gamma function.\n		/// \\param arg function argument\n		/// \\return natural logarith of gamma function for \\a arg\n//		template<typename T> typename enable<expr,T>::type lgamma(T arg) { return functions::lgamma(arg); }\n		inline expr lgamma(half arg) { return functions::lgamma(arg); }\n		inline expr lgamma(expr arg) { return functions::lgamma(arg); }\n\n		/// Gamma function.\n		/// \\param arg function argument\n		/// \\return gamma function value of \\a arg\n//		template<typename T> typename enable<expr,T>::type tgamma(T arg) { return functions::tgamma(arg); }\n		inline expr tgamma(half arg) { return functions::tgamma(arg); }\n		inline expr tgamma(expr arg) { return functions::tgamma(arg); }\n\n		/// \\}\n		/// \\name Rounding\n		/// \\{\n\n		/// Nearest integer not less than half value.\n		/// \\param arg half to round\n		/// \\return nearest integer not less than \\a arg\n//		template<typename T> typename enable<half,T>::type ceil(T arg) { return functions::ceil(arg); }\n		inline half ceil(half arg) { return functions::ceil(arg); }\n		inline half ceil(expr arg) { return functions::ceil(arg); }\n\n		/// Nearest integer not greater than half value.\n		/// \\param arg half to round\n		/// \\return nearest integer not greater than \\a arg\n//		template<typename T> typename enable<half,T>::type floor(T arg) { return functions::floor(arg); }\n		inline half floor(half arg) { return functions::floor(arg); }\n		inline half floor(expr arg) { return functions::floor(arg); }\n\n		/// Nearest integer not greater in magnitude than half value.\n		/// \\param arg half to round\n		/// \\return nearest integer not greater in magnitude than \\a arg\n//		template<typename T> typename enable<half,T>::type trunc(T arg) { return functions::trunc(arg); }\n		inline half trunc(half arg) { return functions::trunc(arg); }\n		inline half trunc(expr arg) { return functions::trunc(arg); }\n\n		/// Nearest integer.\n		/// \\param arg half to round\n		/// \\return nearest integer, rounded away from zero in half-way cases\n//		template<typename T> typename enable<half,T>::type round(T arg) { return functions::round(arg); }\n		inline half round(half arg) { return functions::round(arg); }\n		inline half round(expr arg) { return functions::round(arg); }\n\n		/// Nearest integer.\n		/// \\param arg half to round\n		/// \\return nearest integer, rounded away from zero in half-way cases\n//		template<typename T> typename enable<long,T>::type lround(T arg) { return functions::lround(arg); }\n		inline long lround(half arg) { return functions::lround(arg); }\n		inline long lround(expr arg) { return functions::lround(arg); }\n\n		/// Nearest integer using half's internal rounding mode.\n		/// \\param arg half expression to round\n		/// \\return nearest integer using default rounding mode\n//		template<typename T> typename enable<half,T>::type nearbyint(T arg) { return functions::nearbyint(arg); }\n		inline half nearbyint(half arg) { return functions::rint(arg); }\n		inline half nearbyint(expr arg) { return functions::rint(arg); }\n\n		/// Nearest integer using half's internal rounding mode.\n		/// \\param arg half expression to round\n		/// \\return nearest integer using default rounding mode\n//		template<typename T> typename enable<half,T>::type rint(T arg) { return functions::rint(arg); }\n		inline half rint(half arg) { return functions::rint(arg); }\n		inline half rint(expr arg) { return functions::rint(arg); }\n\n		/// Nearest integer using half's internal rounding mode.\n		/// \\param arg half expression to round\n		/// \\return nearest integer using default rounding mode\n//		template<typename T> typename enable<long,T>::type lrint(T arg) { return functions::lrint(arg); }\n		inline long lrint(half arg) { return functions::lrint(arg); }\n		inline long lrint(expr arg) { return functions::lrint(arg); }\n	#if HALF_ENABLE_CPP11_LONG_LONG\n		/// Nearest integer.\n		/// \\param arg half to round\n		/// \\return nearest integer, rounded away from zero in half-way cases\n//		template<typename T> typename enable<long long,T>::type llround(T arg) { return functions::llround(arg); }\n		inline long long llround(half arg) { return functions::llround(arg); }\n		inline long long llround(expr arg) { return functions::llround(arg); }\n\n		/// Nearest integer using half's internal rounding mode.\n		/// \\param arg half expression to round\n		/// \\return nearest integer using default rounding mode\n//		template<typename T> typename enable<long long,T>::type llrint(T arg) { return functions::llrint(arg); }\n		inline long long llrint(half arg) { return functions::llrint(arg); }\n		inline long long llrint(expr arg) { return functions::llrint(arg); }\n	#endif\n\n		/// \\}\n		/// \\name Floating point manipulation\n		/// \\{\n\n		/// Decompress floating point number.\n		/// \\param arg number to decompress\n		/// \\param exp address to store exponent at\n		/// \\return significant in range [0.5, 1)\n//		template<typename T> typename enable<half,T>::type frexp(T arg, int *exp) { return functions::frexp(arg, exp); }\n		inline half frexp(half arg, int *exp) { return functions::frexp(arg, exp); }\n		inline half frexp(expr arg, int *exp) { return functions::frexp(arg, exp); }\n\n		/// Multiply by power of two.\n		/// \\param arg number to modify\n		/// \\param exp power of two to multiply with\n		/// \\return \\a arg multplied by 2 raised to \\a exp\n//		template<typename T> typename enable<half,T>::type ldexp(T arg, int exp) { return functions::scalbln(arg, exp); }\n		inline half ldexp(half arg, int exp) { return functions::scalbln(arg, exp); }\n		inline half ldexp(expr arg, int exp) { return functions::scalbln(arg, exp); }\n\n		/// Extract integer and fractional parts.\n		/// \\param arg number to decompress\n		/// \\param iptr address to store integer part at\n		/// \\return fractional part\n//		template<typename T> typename enable<half,T>::type modf(T arg, half *iptr) { return functions::modf(arg, iptr); }\n		inline half modf(half arg, half *iptr) { return functions::modf(arg, iptr); }\n		inline half modf(expr arg, half *iptr) { return functions::modf(arg, iptr); }\n\n		/// Multiply by power of two.\n		/// \\param arg number to modify\n		/// \\param exp power of two to multiply with\n		/// \\return \\a arg multplied by 2 raised to \\a exp\n//		template<typename T> typename enable<half,T>::type scalbn(T arg, int exp) { return functions::scalbln(arg, exp); }\n		inline half scalbn(half arg, int exp) { return functions::scalbln(arg, exp); }\n		inline half scalbn(expr arg, int exp) { return functions::scalbln(arg, exp); }\n\n		/// Multiply by power of two.\n		/// \\param arg number to modify\n		/// \\param exp power of two to multiply with\n		/// \\return \\a arg multplied by 2 raised to \\a exp	\n//		template<typename T> typename enable<half,T>::type scalbln(T arg, long exp) { return functions::scalbln(arg, exp); }\n		inline half scalbln(half arg, long exp) { return functions::scalbln(arg, exp); }\n		inline half scalbln(expr arg, long exp) { return functions::scalbln(arg, exp); }\n\n		/// Extract exponent.\n		/// \\param arg number to query\n		/// \\return floating point exponent\n		/// \\retval FP_ILOGB0 for zero\n		/// \\retval FP_ILOGBNAN for NaN\n		/// \\retval MAX_INT for infinity\n//		template<typename T> typename enable<int,T>::type ilogb(T arg) { return functions::ilogb(arg); }\n		inline int ilogb(half arg) { return functions::ilogb(arg); }\n		inline int ilogb(expr arg) { return functions::ilogb(arg); }\n\n		/// Extract exponent.\n		/// \\param arg number to query\n		/// \\return floating point exponent\n//		template<typename T> typename enable<half,T>::type logb(T arg) { return functions::logb(arg); }\n		inline half logb(half arg) { return functions::logb(arg); }\n		inline half logb(expr arg) { return functions::logb(arg); }\n\n		/// Next representable value.\n		/// \\param from value to compute next representable value for\n		/// \\param to direction towards which to compute next value\n		/// \\return next representable value after \\a from in direction towards \\a to\n//		template<typename T,typename U> typename enable<half,T,U>::type nextafter(T from, U to) { return functions::nextafter(from, to); }\n		inline half nextafter(half from, half to) { return functions::nextafter(from, to); }\n		inline half nextafter(half from, expr to) { return functions::nextafter(from, to); }\n		inline half nextafter(expr from, half to) { return functions::nextafter(from, to); }\n		inline half nextafter(expr from, expr to) { return functions::nextafter(from, to); }\n\n		/// Next representable value.\n		/// \\param from value to compute next representable value for\n		/// \\param to direction towards which to compute next value\n		/// \\return next representable value after \\a from in direction towards \\a to\n//		template<typename T> typename enable<half,T>::type nexttoward(T from, long double to) { return functions::nexttoward(from, to); }\n		inline half nexttoward(half from, long double to) { return functions::nexttoward(from, to); }\n		inline half nexttoward(expr from, long double to) { return functions::nexttoward(from, to); }\n\n		/// Take sign.\n		/// \\param x value to change sign for\n		/// \\param y value to take sign from\n		/// \\return value equal to \\a x in magnitude and to \\a y in sign\n//		template<typename T,typename U> typename enable<half,T,U>::type copysign(T x, U y) { return functions::copysign(x, y); }\n		inline half copysign(half x, half y) { return functions::copysign(x, y); }\n		inline half copysign(half x, expr y) { return functions::copysign(x, y); }\n		inline half copysign(expr x, half y) { return functions::copysign(x, y); }\n		inline half copysign(expr x, expr y) { return functions::copysign(x, y); }\n\n		/// \\}\n		/// \\name Floating point classification\n		/// \\{\n\n\n		/// Classify floating point value.\n		/// \\param arg number to classify\n		/// \\retval FP_ZERO for positive and negative zero\n		/// \\retval FP_SUBNORMAL for subnormal numbers\n		/// \\retval FP_INFINITY for positive and negative infinity\n		/// \\retval FP_NAN for NaNs\n		/// \\retval FP_NORMAL for all other (normal) values\n//		template<typename T> typename enable<int,T>::type fpclassify(T arg) { return functions::fpclassify(arg); }\n		inline int fpclassify(half arg) { return functions::fpclassify(arg); }\n		inline int fpclassify(expr arg) { return functions::fpclassify(arg); }\n\n		/// Check if finite number.\n		/// \\param arg number to check\n		/// \\retval true if neither infinity nor NaN\n		/// \\retval false else\n//		template<typename T> typename enable<bool,T>::type isfinite(T arg) { return functions::isfinite(arg); }\n		inline bool isfinite(half arg) { return functions::isfinite(arg); }\n		inline bool isfinite(expr arg) { return functions::isfinite(arg); }\n\n		/// Check for infinity.\n		/// \\param arg number to check\n		/// \\retval true for positive or negative infinity\n		/// \\retval false else\n//		template<typename T> typename enable<bool,T>::type isinf(T arg) { return functions::isinf(arg); }\n		inline bool isinf(half arg) { return functions::isinf(arg); }\n		inline bool isinf(expr arg) { return functions::isinf(arg); }\n\n		/// Check for NaN.\n		/// \\param arg number to check\n		/// \\retval true for NaNs\n		/// \\retval false else\n//		template<typename T> typename enable<bool,T>::type isnan(T arg) { return functions::isnan(arg); }\n		inline bool isnan(half arg) { return functions::isnan(arg); }\n		inline bool isnan(expr arg) { return functions::isnan(arg); }\n\n		/// Check if normal number.\n		/// \\param arg number to check\n		/// \\retval true if normal number\n		/// \\retval false if either subnormal, zero, infinity or NaN\n//		template<typename T> typename enable<bool,T>::type isnormal(T arg) { return functions::isnormal(arg); }\n		inline bool isnormal(half arg) { return functions::isnormal(arg); }\n		inline bool isnormal(expr arg) { return functions::isnormal(arg); }\n\n		/// Check sign.\n		/// \\param arg number to check\n		/// \\retval true for negative number\n		/// \\retval false for positive number\n//		template<typename T> typename enable<bool,T>::type signbit(T arg) { return functions::signbit(arg); }\n		inline bool signbit(half arg) { return functions::signbit(arg); }\n		inline bool signbit(expr arg) { return functions::signbit(arg); }\n\n		/// \\}\n		/// \\name Comparison\n		/// \\{\n\n		/// Comparison for greater than.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\retval true if \\a x greater than \\a y\n		/// \\retval false else\n//		template<typename T,typename U> typename enable<bool,T,U>::type isgreater(T x, U y) { return functions::isgreater(x, y); }\n		inline bool isgreater(half x, half y) { return functions::isgreater(x, y); }\n		inline bool isgreater(half x, expr y) { return functions::isgreater(x, y); }\n		inline bool isgreater(expr x, half y) { return functions::isgreater(x, y); }\n		inline bool isgreater(expr x, expr y) { return functions::isgreater(x, y); }\n\n		/// Comparison for greater equal.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\retval true if \\a x greater equal \\a y\n		/// \\retval false else\n//		template<typename T,typename U> typename enable<bool,T,U>::type isgreaterequal(T x, U y) { return functions::isgreaterequal(x, y); }\n		inline bool isgreaterequal(half x, half y) { return functions::isgreaterequal(x, y); }\n		inline bool isgreaterequal(half x, expr y) { return functions::isgreaterequal(x, y); }\n		inline bool isgreaterequal(expr x, half y) { return functions::isgreaterequal(x, y); }\n		inline bool isgreaterequal(expr x, expr y) { return functions::isgreaterequal(x, y); }\n\n		/// Comparison for less than.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\retval true if \\a x less than \\a y\n		/// \\retval false else\n//		template<typename T,typename U> typename enable<bool,T,U>::type isless(T x, U y) { return functions::isless(x, y); }\n		inline bool isless(half x, half y) { return functions::isless(x, y); }\n		inline bool isless(half x, expr y) { return functions::isless(x, y); }\n		inline bool isless(expr x, half y) { return functions::isless(x, y); }\n		inline bool isless(expr x, expr y) { return functions::isless(x, y); }\n\n		/// Comparison for less equal.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\retval true if \\a x less equal \\a y\n		/// \\retval false else\n//		template<typename T,typename U> typename enable<bool,T,U>::type islessequal(T x, U y) { return functions::islessequal(x, y); }\n		inline bool islessequal(half x, half y) { return functions::islessequal(x, y); }\n		inline bool islessequal(half x, expr y) { return functions::islessequal(x, y); }\n		inline bool islessequal(expr x, half y) { return functions::islessequal(x, y); }\n		inline bool islessequal(expr x, expr y) { return functions::islessequal(x, y); }\n\n		/// Comarison for less or greater.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\retval true if either less or greater\n		/// \\retval false else\n//		template<typename T,typename U> typename enable<bool,T,U>::type islessgreater(T x, U y) { return functions::islessgreater(x, y); }\n		inline bool islessgreater(half x, half y) { return functions::islessgreater(x, y); }\n		inline bool islessgreater(half x, expr y) { return functions::islessgreater(x, y); }\n		inline bool islessgreater(expr x, half y) { return functions::islessgreater(x, y); }\n		inline bool islessgreater(expr x, expr y) { return functions::islessgreater(x, y); }\n\n		/// Check if unordered.\n		/// \\param x first operand\n		/// \\param y second operand\n		/// \\retval true if unordered (one or two NaN operands)\n		/// \\retval false else\n//		template<typename T,typename U> typename enable<bool,T,U>::type isunordered(T x, U y) { return functions::isunordered(x, y); }\n		inline bool isunordered(half x, half y) { return functions::isunordered(x, y); }\n		inline bool isunordered(half x, expr y) { return functions::isunordered(x, y); }\n		inline bool isunordered(expr x, half y) { return functions::isunordered(x, y); }\n		inline bool isunordered(expr x, expr y) { return functions::isunordered(x, y); }\n\n		/// \\name Casting\n		/// \\{\n\n		/// Cast to or from half-precision floating point number.\n		/// This casts between [half](\\ref half_float::half) and any built-in arithmetic type. Floating point types are \n		/// converted via an explicit cast to/from `float` (using the rounding mode of the built-in single precision \n		/// implementation) and thus any possible warnings due to an otherwise implicit conversion to/from `float` will be \n		/// suppressed. Integer types are converted directly using the given rounding mode, without any roundtrip over `float` \n		/// that a `static_cast` would otherwise do. It uses the default rounding mode.\n		///\n		/// Using this cast with neither of the two types being a [half](\\ref half_float::half) or with any of the two types \n		/// not being a built-in arithmetic type (apart from [half](\\ref half_float::half), of course) results in a compiler \n		/// error and casting between [half](\\ref half_float::half)s is just a no-op.\n		/// \\tparam T destination type (half or built-in arithmetic type)\n		/// \\tparam U source type (half or built-in arithmetic type)\n		/// \\param arg value to cast\n		/// \\return \\a arg converted to destination type\n		template<typename T,typename U> typename half_caster<T,U>::type half_cast(U arg) { return half_caster<T,U>::cast(arg); }\n\n		/// Cast to or from half-precision floating point number.\n		/// This casts between [half](\\ref half_float::half) and any built-in arithmetic type. Floating point types are \n		/// converted via an explicit cast to/from `float` (using the rounding mode of the built-in single precision \n		/// implementation) and thus any possible warnings due to an otherwise implicit conversion to/from `float` will be \n		/// suppressed. Integer types are converted directly using the given rounding mode, without any roundtrip over `float` \n		/// that a `static_cast` would otherwise do.\n		///\n		/// Using this cast with neither of the two types being a [half](\\ref half_float::half) or with any of the two types \n		/// not being a built-in arithmetic type (apart from [half](\\ref half_float::half), of course) results in a compiler \n		/// error and casting between [half](\\ref half_float::half)s is just a no-op.\n		/// \\tparam T destination type (half or built-in arithmetic type)\n		/// \\tparam R rounding mode to use.\n		/// \\tparam U source type (half or built-in arithmetic type)\n		/// \\param arg value to cast\n		/// \\return \\a arg converted to destination type\n		template<typename T,std::float_round_style R,typename U> typename half_caster<T,U,R>::type half_cast(U arg)\n			{ return half_caster<T,U,R>::cast(arg); }\n		/// \\}\n	}\n\n	using detail::operator==;\n	using detail::operator!=;\n	using detail::operator<;\n	using detail::operator>;\n	using detail::operator<=;\n	using detail::operator>=;\n	using detail::operator+;\n	using detail::operator-;\n	using detail::operator*;\n	using detail::operator/;\n	using detail::operator<<;\n	using detail::operator>>;\n\n	using detail::abs;\n	using detail::fabs;\n	using detail::fmod;\n	using detail::remainder;\n	using detail::remquo;\n	using detail::fma;\n	using detail::fmax;\n	using detail::fmin;\n	using detail::fdim;\n	using detail::nanh;\n	using detail::exp;\n	using detail::expm1;\n	using detail::exp2;\n	using detail::log;\n	using detail::log10;\n	using detail::log1p;\n	using detail::log2;\n	using detail::sqrt;\n	using detail::cbrt;\n	using detail::hypot;\n	using detail::pow;\n	using detail::sin;\n	using detail::cos;\n	using detail::tan;\n	using detail::asin;\n	using detail::acos;\n	using detail::atan;\n	using detail::atan2;\n	using detail::sinh;\n	using detail::cosh;\n	using detail::tanh;\n	using detail::asinh;\n	using detail::acosh;\n	using detail::atanh;\n	using detail::erf;\n	using detail::erfc;\n	using detail::lgamma;\n	using detail::tgamma;\n	using detail::ceil;\n	using detail::floor;\n	using detail::trunc;\n	using detail::round;\n	using detail::lround;\n	using detail::nearbyint;\n	using detail::rint;\n	using detail::lrint;\n#if HALF_ENABLE_CPP11_LONG_LONG\n	using detail::llround;\n	using detail::llrint;\n#endif\n	using detail::frexp;\n	using detail::ldexp;\n	using detail::modf;\n	using detail::scalbn;\n	using detail::scalbln;\n	using detail::ilogb;\n	using detail::logb;\n	using detail::nextafter;\n	using detail::nexttoward;\n	using detail::copysign;\n	using detail::fpclassify;\n	using detail::isfinite;\n	using detail::isinf;\n	using detail::isnan;\n	using detail::isnormal;\n	using detail::signbit;\n	using detail::isgreater;\n	using detail::isgreaterequal;\n	using detail::isless;\n	using detail::islessequal;\n	using detail::islessgreater;\n	using detail::isunordered;\n\n	using detail::half_cast;\n}\n\n\n/// Extensions to the C++ standard library.\nnamespace std\n{\n	/// Numeric limits for half-precision floats.\n	/// Because of the underlying single-precision implementation of many operations, it inherits some properties from \n	/// `std::numeric_limits<float>`.\n	template<> class numeric_limits<half_float::half> : public numeric_limits<float>\n	{\n	public:\n		/// Supports signed values.\n		static HALF_CONSTEXPR_CONST bool is_signed = true;\n\n		/// Is not exact.\n		static HALF_CONSTEXPR_CONST bool is_exact = false;\n\n		/// Doesn't provide modulo arithmetic.\n		static HALF_CONSTEXPR_CONST bool is_modulo = false;\n\n		/// IEEE conformant.\n		static HALF_CONSTEXPR_CONST bool is_iec559 = true;\n\n		/// Supports infinity.\n		static HALF_CONSTEXPR_CONST bool has_infinity = true;\n\n		/// Supports quiet NaNs.\n		static HALF_CONSTEXPR_CONST bool has_quiet_NaN = true;\n\n		/// Supports subnormal values.\n		static HALF_CONSTEXPR_CONST float_denorm_style has_denorm = denorm_present;\n\n		/// Rounding mode.\n		/// Due to the mix of internal single-precision computations (using the rounding mode of the underlying \n		/// single-precision implementation) with explicit truncation of the single-to-half conversions, the actual rounding \n		/// mode is indeterminate.\n		static HALF_CONSTEXPR_CONST float_round_style round_style = (std::numeric_limits<float>::round_style==\n			half_float::half::round_style) ? half_float::half::round_style : round_indeterminate;\n\n		/// Significant digits.\n		static HALF_CONSTEXPR_CONST int digits = 11;\n\n		/// Significant decimal digits.\n		static HALF_CONSTEXPR_CONST int digits10 = 3;\n\n		/// Required decimal digits to represent all possible values.\n		static HALF_CONSTEXPR_CONST int max_digits10 = 5;\n\n		/// Number base.\n		static HALF_CONSTEXPR_CONST int radix = 2;\n\n		/// One more than smallest exponent.\n		static HALF_CONSTEXPR_CONST int min_exponent = -13;\n\n		/// Smallest normalized representable power of 10.\n		static HALF_CONSTEXPR_CONST int min_exponent10 = -4;\n\n		/// One more than largest exponent\n		static HALF_CONSTEXPR_CONST int max_exponent = 16;\n\n		/// Largest finitely representable power of 10.\n		static HALF_CONSTEXPR_CONST int max_exponent10 = 4;\n\n		/// Smallest positive normal value.\n		static HALF_CONSTEXPR half_float::half min() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x0400); }\n\n		/// Smallest finite value.\n		static HALF_CONSTEXPR half_float::half lowest() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0xFBFF); }\n\n		/// Largest finite value.\n		static HALF_CONSTEXPR half_float::half max() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x7BFF); }\n\n		/// Difference between one and next representable value.\n		static HALF_CONSTEXPR half_float::half epsilon() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x1400); }\n\n		/// Maximum rounding error.\n		static HALF_CONSTEXPR half_float::half round_error() HALF_NOTHROW\n			{ return half_float::half(half_float::detail::binary, (round_style==std::round_to_nearest) ? 0x3800 : 0x3C00); }\n\n		/// Positive infinity.\n		static HALF_CONSTEXPR half_float::half infinity() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x7C00); }\n\n		/// Quiet NaN.\n		static HALF_CONSTEXPR half_float::half quiet_NaN() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x7FFF); }\n\n		/// Signalling NaN.\n		static HALF_CONSTEXPR half_float::half signaling_NaN() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x7DFF); }\n\n		/// Smallest positive subnormal value.\n		static HALF_CONSTEXPR half_float::half denorm_min() HALF_NOTHROW { return half_float::half(half_float::detail::binary, 0x0001); }\n	};\n\n#if HALF_ENABLE_CPP11_HASH\n	/// Hash function for half-precision floats.\n	/// This is only defined if C++11 `std::hash` is supported and enabled.\n	template<> struct hash<half_float::half> //: unary_function<half_float::half,size_t>\n	{\n		/// Type of function argument.\n		typedef half_float::half argument_type;\n\n		/// Function return type.\n		typedef size_t result_type;\n\n		/// Compute hash function.\n		/// \\param arg half to hash\n		/// \\return hash value\n		result_type operator()(argument_type arg) const\n			{ return hash<half_float::detail::uint16>()(static_cast<unsigned int>(arg.data_)&-(arg.data_!=0x8000)); }\n	};\n#endif\n}\n\n\n#undef HALF_CONSTEXPR\n#undef HALF_CONSTEXPR_CONST\n#undef HALF_NOEXCEPT\n#undef HALF_NOTHROW\n#ifdef HALF_POP_WARNINGS\n	#pragma warning(pop)\n	#undef HALF_POP_WARNINGS\n#endif\n\n#endif\n",
			"file": "/C/Users/deano/AppData/Local/Temp/Temp1_half-1.11.0.zip/half-1.11.0/include/half.hpp",
			"file_size": -1,
			"file_write_time": -1,
			"settings":
			{
				"buffer_size": 142502,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 312.0,
		"selected_items":
		[
			[
				"Package Control: ",
				"Package Control: Discover Packages"
			],
			[
				"Package Control: inst",
				"Package Control: Install Package"
			],
			[
				"Package Control: discover",
				"Package Control: Discover Packages"
			],
			[
				"Package Control: di",
				"Package Control: Disable Package"
			],
			[
				"Package Control: install",
				"Package Control: Install Package"
			],
			[
				"",
				"Bookmarks: Clear All"
			]
		],
		"width": 400.0
	},
	"console":
	{
		"height": 146.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/D/Ruffian_Perforce/Halo4/shared/engine/source/blofeld/tool/convert_address_to_symbol.cpp",
		"/C/Users/deano/AppData/Local/Temp/7zO5843.tmp/eLut.cpp",
		"/C/Users/deano/AppData/Local/Temp/Temp1_half-1.11.0.zip/half-1.11.0/LICENSE.txt",
		"/C/Users/deano/AppData/Local/Temp/7zO1A44.tmp/half.cpp",
		"/C/Users/deano/AppData/Local/Temp/7zOFC3C.tmp/halfExport.h",
		"/C/Users/deano/AppData/Local/Temp/7zOD0C6.tmp/halfLimits.h",
		"/C/Users/deano/AppData/Local/Temp/7zO5291.tmp/halfFunction.h",
		"/C/Users/deano/AppData/Local/Temp/7zO59F7.tmp/half.h",
		"/C/Users/deano/AppData/Local/Temp/Temp1_lesson43.zip/Lesson43/FreeType.cpp",
		"/P/Source/yolk/src/apps/convert/CMakeLists.txt",
		"/P/Source/yolk/src/libs/CMakeLists.txt",
		"/P/Source/yolk/src/libs/zlib/CMakeLists.txt",
		"/P/Source/yolk/src/libs/freetype-2.5.3/CMakeLists.txt",
		"/C/Users/deano/AppData/Local/Temp/p4v/BlueBoy_10.0.10.11_1666/Groundhog/Halo4/shared/engine/source/blofeld/geometry/geometry_definitions#8.cpp",
		"/D/Ruffian_Perforce/Halo4/data/shaders/material_shaders/materials/water/water.fx",
		"/D/Ruffian_Perforce/Halo4/Durango/Pull_Mapping.xml",
		"/C/Users/deano/AppData/Local/Temp/Temp1_texture_creation.zip/texture_creation/edtaa3func.c",
		"/P/Source/yolk/src/apps/gfx_test/main.cpp",
		"/P/Source/yolk/src/libs/dx11/databuffer.h",
		"/P/Source/yolk/src/libs/gl/databuffer.h",
		"/P/Source/yolk/src/libs/gl/gfx.cpp",
		"/P/Source/yolk/src/libs/dx11/gfx.cpp",
		"/P/Source/yolk/src/libs/scene/programman.cpp",
		"/P/Source/yolk/src/libs/dx11/resource.cpp",
		"/C/Users/deano/AppData/Local/Temp/Temp1_texture_creation.zip/texture_creation/edtaa3.c",
		"/D/Temp/interactive_demo_win32/GLSL-contourtextures.c",
		"/P/Source/yolk/src/libs/gl/databuffer.cpp",
		"/P/Source/yolk/src/apps/resilience/main.cpp",
		"/P/Source/yolk/src/apps/CMakeLists.txt",
		"/P/Source/yolk/cmake_modules/FindDirectX.cmake",
		"/P/Source/yolk/yolk_setup.cmake",
		"/C/Projects/TripWire/KillingFloor/OpenGLDrv/Src/OpenGLRenderInterface.cpp",
		"/C/Projects/emf/lsm303dlhc_read.ino",
		"/C/Projects/TripWire/KillingFloor/OpenGLDrv/Src/OpenGLRenderDevice.cpp",
		"/C/Projects/emf/drsac_emf1/drsac_emf.ino",
		"/C/Projects/TripWire/KillingFloor/Engine/Src/UnEngine.cpp",
		"/C/Projects/TripWire/KillingFloor/OpenGLDrv/Src/OpenGLMaterialState.cpp",
		"/C/Projects/TripWire/KillingFloor/OpenGLDrv/Src/trip_postfx_opengl.cpp",
		"/C/Projects/TripWire/KillingFloor/OpenGLDrv/Src/OpenGLDrv.cpp",
		"/C/Projects/yolk/src/apps/resilience/CMakeLists.txt",
		"/C/Projects/yolk/yolk.sublime-project",
		"/C/Projects/yolk/src/libs/sandbox/sandbox.cpp",
		"/G/Projects/SDL2-2.0.0/src/render/opengles2/SDL_gles2funcs.h",
		"/G/Projects/SDL2-2.0.0/src/render/opengles2/SDL_shaders_gles2.h",
		"/G/Projects/SDL2-2.0.0/src/render/opengles2/SDL_render_gles2.c",
		"/G/AdrenoSDK/Development/Samples/OpenGLES30/CompressedGeometry/CompressedMesh.cpp",
		"/G/AdrenoSDK/Development/Samples/Framework/OpenGLES/FrmGLES3.cpp",
		"/G/Projects/SDL2-2.0.0/src/render/opengles2/SDL_shaders_gles2.c",
		"/G/builds/llvm/share/llvm/cmake/LLVMConfig.cmake",
		"/C/Projects/yolk/src/libs/sandbox/sandbox.h",
		"/G/Projects/RBDOOM-3-BFG/neo/CMakeLists.txt",
		"/G/AdrenoSDK/Development/Samples/OpenGLES30/CompressedGeometry/VS2010/CompressedGeometry.vcxproj",
		"/G/AdrenoSDK/Development/Samples/OpenGLES30/CompressedGeometry/Scene.cpp",
		"/G/AdrenoSDK/Development/Samples/OpenGLES30/CompressedGeometry/Eigenvector.cpp",
		"/G/Projects/SDL2-2.0.0/README-directfb.txt",
		"/G/Projects/SDL2-2.0.0/README-platforms.txt",
		"/G/Projects/SDL2-2.0.0/README-porting.txt",
		"/G/Projects/native_client/src/include/nacl/nacl_minidump.h",
		"/G/Projects/native_client/src/include/nacl_asm.h",
		"/G/Projects/native_client/src/third_party/valgrind/README",
		"/G/Projects/native_client/src/third_party/dlmalloc/README.nacl",
		"/G/Projects/native_client/src/third_party/dlmalloc/NOTICE",
		"/G/Projects/native_client/src/untrusted/pthread/nc_condvar.c",
		"/G/Projects/native_client/src/untrusted/nosys/pclose.c",
		"/G/Projects/native_client/src/untrusted/nosys/chmod.c",
		"/G/builds/llvm/examples/BrainF/BrainF.vcxproj",
		"/G/builds/llvm/share/llvm/cmake/LLVMConfigVersion.cmake",
		"/G/Projects/yolk/src/libs/CMakeLists.txt",
		"/G/Projects/yolk/src/apps/gfx_test/voxtree_test.cpp",
		"/G/Projects/yolk/src/libs/core/aabb.h",
		"/G/Projects/yolk/src/libs/core/aabb.inl",
		"/G/Projects/yolk/src/libs/core/kdtree.cpp",
		"/G/Projects/yolk/src/libs/core/kdtree.h",
		"/G/Projects/yolk/src/libs/core/luastate.h",
		"/G/Projects/yolk/src/libs/core/rasteriser.cpp",
		"/G/Projects/yolk/src/libs/core/rasteriser.h",
		"/G/Projects/yolk/src/libs/core/ray.cpp",
		"/G/Projects/yolk/src/libs/core/ray.h",
		"/G/Projects/yolk/src/libs/core/resource_dir.h",
		"/G/Projects/yolk/src/libs/core/resourcebase.h",
		"/G/Projects/yolk/src/libs/core/resourceman.h",
		"/G/Projects/yolk/src/libs/core/resources.h",
		"/G/Projects/yolk/src/libs/core/platform_windows/win_shell.h",
		"/G/Projects/yolk/src/libs/dx11/dxgiformat_cracker.h",
		"/G/Projects/yolk/src/libs/gl/debugpipeline.h",
		"/G/Projects/yolk/src/libs/gl/glformat_cracker.h",
		"/G/Projects/yolk/src/libs/gl/vtpipeline.h",
		"/G/Projects/yolk/src/libs/gl/wobbackend.h",
		"/G/Projects/yolk/src/libs/meshmod/edge.cpp",
		"/G/Projects/yolk/src/libs/meshops/floattexture.cpp",
		"/G/Projects/yolk/src/libs/meshops/floattexture.h",
		"/G/Projects/yolk/src/libs/meshops/raycaster.cpp",
		"/G/Projects/yolk/src/libs/meshops/raycaster.h",
		"/G/Projects/yolk/src/libs/meshops/textureunit.cpp",
		"/G/Projects/yolk/src/libs/meshops/textureunit.h",
		"/G/Projects/yolk/src/libs/dx11/gfx.cpp",
		"/G/Projects/yolk/src/libs/scene/gtfcracker.h",
		"/G/Projects/yolk/src/libs/scene/debugpipeline.h",
		"/G/Projects/yolk/src/apps/gfx_test/proceduraltextureutils.cpp",
		"/G/Projects/yolk/src/apps/gfx_test/proceduraltextureutils.h",
		"/G/Projects/yolk/src/apps/gfx_test/procvoxtree.h",
		"/G/Projects/yolk/src/apps/gfx_test/procvoxtree.cpp",
		"/G/Projects/yolk/src/libs/scene/renderer.h",
		"/G/Projects/yolk/src/libs/dwm/bitcoder.cpp",
		"/G/Projects/yolk/src/libs/sandbox/CMakeLists.txt",
		"/G/Projects/yolk/src/libs/cl/clformatcracker.h",
		"/G/Projects/yolk/src/libs/scene/pipeline.h",
		"/G/Projects/yolk/src/libs/scene/vtpipeline.h",
		"/G/Projects/native_client/src/shared/ldr/nacl_ldr.c",
		"/G/Projects/yolk/yolk.sublime-project",
		"/G/Projects/iipmooviewer-1.1/iipmooviewer.html",
		"/G/Projects/iipmooviewer-1.1/javascript/iipmooviewer-1.1.js",
		"/G/Projects/Aura2/MWare/Common/TaskMgr/tbb30/include/tbb/parallel_while.h",
		"/G/Projects/Aura2/MWare/Common/TaskMgr/tbb30/include/tbb/parallel_do.h",
		"/G/Projects/iipmooviewer-1.1/iipmooviewer2.html",
		"/C/Users/AndroidDev/Desktop/DwarfCorp/README.txt",
		"/G/Projects/Aura2/MWare/Common/TaskMgr/tbb30/include/tbb/parallel_for_each.h",
		"/G/Projects/Aura2/MWare/Common/TaskMgr/tbb30/include/tbb/compat/ppl.h",
		"/G/Projects/Aura2/MWare/Common/TaskMgr/tbb30/include/tbb/parallel_invoke.h",
		"/G/Projects/yolk/yolk_setup.cmake",
		"/G/Projects/yolk/src/libs/core/buildconfig.h.in",
		"/G/Projects/yolk/src/apps/gfx_test/voxtree.h",
		"/G/Projects/yolk/src/apps/gfx_test/voxtree.inl",
		"/G/Projects/yolk/src/apps/gfx_test/voxtreerenderable.inl",
		"/G/Projects/yolk/src/apps/gfx_test/voxtreephysical.inl",
		"/G/Projects/yolk/src/libs/dx11/gfx.h",
		"/C/Users/AndroidDev/AppData/Local/Temp/7zO23F3.tmp/ImageEffects.cpp",
		"/G/Projects/yolk/src/apps/gfx_test/shell3d.cpp"
	],
	"find":
	{
		"height": 44.0
	},
	"find_in_files":
	{
		"height": 135.0,
		"where_history":
		[
			"",
			"Z:\\Projects\\Cyberspace\\yolk_repo\\submodules\\native_client\\src\\native_client\\src",
			"",
			"Z:\\Projects\\Cyberspace\\yolk_repo\\submodules\\native_client\\src\\native_client",
			"Z:\\Projects\\Cyberspace\\yolk_repo\\submodules\\llvm",
			"Z:\\Projects\\Cyberspace\\yolk_repo\\submodules\\native_client\\src\\native_client\\src",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"BufferATI",
			"LLVM_ROOT",
			"rattie.demon.co.uk",
			"iscanvas",
			"Singleton",
			"Clamp",
			"SmoothStep",
			"h",
			"RESOURCE_NAME",
			"AABB",
			"_clientVersion",
			"SwfParser/",
			"SwfParser",
			"platform_windows",
			"__TBB_machine_load8",
			"__TBB_machine_cas_32",
			"GenerateID",
			".*;</",
			"\".\",",
			"cpp",
			"#include \"pch.h\"",
			"SwfParser",
			"Zombie House Studios",
			"2008 Zombie House Studios",
			"Enemy",
			"{\n",
			"debug",
			"debugf",
			"vtdfh.h",
			"RasteriserState",
			"internalPreCreate",
			"internalLoad",
			"CreationInfo",
			"PreCreateStruct",
			"LoadStruct",
			"GL_",
			"YOLK_SCENE_PROGRAM_MAN_H_",
			"TextureCtor",
			"swapChain",
			"YOLK_GL_VALIDATE_PRG_OFFSETS",
			"Gl::MAX_PROGRAM_TYPE",
			"DECLARE_FRAGMENT",
			";",
			":",
			"GL_",
			"RENDER_BACKEND",
			"VaoElement",
			"CF_STATIC",
			"CONSTANT_FREQ_BLOCKS",
			"WIERD_GL_GET_SIZEOF_PRG_VAR",
			"WIERD_GL_GET_OFFSET_IN_BLOCK",
			"WIERD_GL_VALIDATE_PRG_OFFSETS",
			"WIERD_GL_GET_OFFSET_IN_BLOCK",
			"Gl",
			"GLEWAPIENTRY",
			"add_custom_command",
			"obj",
			"asm",
			"obj",
			"asm",
			"<?",
			"LLVM_PREPROCESSOR",
			"LLVM_ASM",
			"asm",
			"glxew",
			"glXGetProcAddressARB",
			"GL_LINEAR",
			"GL_UNIFORM_BUFFER",
			"expired",
			"LWSurfPolyTag",
			"getS",
			"LoadObjectLayer",
			"fmatrix44",
			"modelFactory",
			"Log",
			"glBindVertexArray",
			"DataBuffer",
			"DataBufferMan",
			"glBind",
			"Vao",
			"GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB",
			"pRD->resource",
			"deano@zombiehousestudios.com",
			"2010",
			"Zombie House Studios",
			"m_impl",
			"tbb_rml",
			"make_private_server",
			"glXGetVisualFromFBConfig",
			"GLXFBConfig",
			"X11/",
			"GL/gl",
			"GL/gh",
			"GL/gl",
			"glxContext",
			"uiSizeOfMainBlock",
			"m_pInterface",
			"XKeyPress",
			"setCamera",
			"Camera",
			"CameraPtr",
			"CORE_ALIGN",
			"ALIGN",
			"dynamic_pointer_cast",
			"radians",
			"degrees_to_radians",
			"GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
			"GLX_CONTEXT_MINOR_VERSION_ARB",
			"glBindFramebuffer",
			"baseName",
			"MakeBaseFilename",
			"loadCreateResource",
			"addRelocationForSymbol",
			"Expected External Symbol",
			"SceneCapturePipeline",
			"GL_NO_ERROR",
			"0x88f0",
			"OffsetEXT\nOffsetEXT",
			"OffsetEXT",
			"#",
			"VertexArrayVertexAttribOffset",
			"VertexAttribOffset",
			"VertexArrayVertexAttribOffset",
			"VertexAttribOffset",
			"VertexArrayVertexAttribOffset",
			"VertexArrayVertexAttribOffsetEXT",
			"glVertexArrayVertexAttribOffsetEXT",
			"REGISTER_SHARED_WITH_CL"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"BufferARB",
			"cloudpixies.com",
			"_serverVersion",
			"swfparser/",
			"#include \"swfruntime.h\"",
			"Parser",
			"2012 Cloud Pixies Ltd",
			"Item",
			"DepthStencilState",
			"RenderTargetStates",
			"internalPreCreate",
			"CreationInfo",
			"PreCreateStruct",
			"GTF_",
			"YOLK_VALIDATE_PRG_OFFSETS",
			"MAX_SHADER_TYPES",
			"DECLARE_SHADER",
			":",
			";",
			"GTF_",
			"VinElement&",
			"YOLK_GL_GET_SIZEOF_PRG_VAR",
			"YOLK_GL_GET_OFFSET_IN_BLOCK",
			"YOLK_GL_VALIDATE_PRG_OFFSETS",
			"Scene",
			"Math::Matrix4x4",
			"LOG(INFO)",
			"Cloud Pixies Ltd",
			"impl",
			"dcinterface",
			"SandboxMemoryManager",
			"NaClJITMemoryManagerX",
			"${BASE_DIR}",
			"",
			"void",
			"void*"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/apps/convert/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 838,
						"regions":
						{
						},
						"selection":
						[
							[
								486,
								486
							]
						],
						"settings":
						{
							"syntax": "Packages/CMake/CMake.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "/C/Users/deano/AppData/Local/Temp/Temp1_half-1.11.0.zip/half-1.11.0/include/half.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 142502,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								142502
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 6912.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 44.0
	},
	"input":
	{
		"height": 39.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.9o://G:\\Projects\\yolk\\src\\libs\\core":
	{
		"height": 208.0
	},
	"output.exec":
	{
		"height": 163.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.unsaved_changes":
	{
		"height": 336.0
	},
	"project": "yolk.sublime-project",
	"replace":
	{
		"height": 84.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
			[
				"math",
				"src/libs/core/vector_math.cpp"
			],
			[
				"main",
				"src/apps/convertmesh/main.cpp"
			],
			[
				"corer",
				"src/libs/core/coreresources.cpp"
			],
			[
				"elf.h",
				"submodules/nacl-llvm/llvm/include/llvm/Support/ELF.h"
			],
			[
				"dwarf",
				"submodules/nacl-llvm/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp"
			],
			[
				"dwarfde",
				"submodules/nacl-llvm/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp"
			],
			[
				"bitcodere",
				"submodules/nacl-llvm/llvm/lib/Bitcode/Reader/BitcodeReader.cpp"
			],
			[
				"runtimey",
				"submodules/nacl-llvm/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp"
			],
			[
				"",
				"submodules/nacl-llvm/llvm/lib/MC/MCELFStreamer.cpp"
			],
			[
				"runtime",
				"submodules/nacl-llvm/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp"
			],
			[
				"platform",
				"src/libs/core/platform.h"
			],
			[
				"registr",
				"submodules/nacl-llvm/llvm/include/llvm/Support/Registry.h"
			],
			[
				"triple",
				"submodules/nacl-llvm/llvm/lib/Support/Triple.cpp"
			],
			[
				"targetreg",
				"submodules/nacl-llvm/llvm/include/llvm/Support/TargetRegistry.h"
			],
			[
				"tiple",
				"submodules/nacl-llvm/llvm/lib/Support/Triple.cpp"
			],
			[
				"targetdata",
				"submodules/nacl-llvm/llvm/include/llvm/Target/TargetData.h"
			],
			[
				"target.",
				"submodules/nacl-llvm/llvm/lib/Target/Target.cpp"
			],
			[
				"target",
				"submodules/nacl-llvm/llvm/lib/Target/Target.cpp"
			],
			[
				"triple.c",
				"submodules/nacl-llvm/llvm/lib/Support/Triple.cpp"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"selected_items":
		[
			[
				"",
				"G:\\Projects\\Aura2\\MWare\\LightPropagationVolumesLib\\lpvliv.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 105.0,
		"selected_items":
		[
			[
				"TreeRnderable",
				"TreeRenderable"
			],
			[
				"TreeRender",
				"TreeRenderable"
			],
			[
				"Thing",
				"Thing"
			]
		],
		"width": 624.0
	},
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 246.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
